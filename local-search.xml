<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器都做了什么</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h1><h2 id="1、解析-URL"><a href="#1、解析-URL" class="headerlink" title="1、解析 URL"></a>1、解析 URL</h2><ul><li>对 URL 进行解析 分析传输协议金和资源路径</li><li>协议或主机名是否合法<ul><li>是 检查 是否存在非法字符 并对其进行转义</li><li>否 内容传输给搜索引擎</li></ul></li></ul><h2 id="2、缓存判断"><a href="#2、缓存判断" class="headerlink" title="2、缓存判断"></a>2、缓存判断</h2><ul><li>浏览器是否存在资源缓存 是有有效<ul><li>是 直接使用</li><li>否 向服务器发起新的请求</li></ul></li></ul><h2 id="3、DNS-解析"><a href="#3、DNS-解析" class="headerlink" title="3、DNS 解析"></a>3、DNS 解析</h2><ul><li>获取 URL 中域名的 IP 地址</li><li>用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求</li><li>检查 本地 DNS 服务器 是否存在该域名的 IP 地址的缓存<ul><li>是 直接使用</li><li>否 请求跟域名服务器 &#x3D;&gt; 获得 负责的顶级域名服务器地址 &#x3D;&gt; 请求负责的顶级域名服务器 &#x3D;&gt; 获得域名的 IP 地址</li></ul></li></ul><h2 id="4、获取-MAC-地址"><a href="#4、获取-MAC-地址" class="headerlink" title="4、获取 MAC 地址"></a>4、获取 MAC 地址</h2><h2 id="5、TCP-三次握手"><a href="#5、TCP-三次握手" class="headerlink" title="5、TCP 三次握手"></a>5、TCP 三次握手</h2><ul><li>确认客户端与服务端的接受与发送能量</li><li>客户端发送 SYN 连接请求报文段和一个随机序号</li><li>服务端确认连接请求 并先客户端发送一个随机序号</li><li>客户端进入连接建立的状态，并向服务器发送一个 ACK 确认报文段</li><li>服务端接收确认后进入连接建立转态</li><li>双方的连接建立完成</li></ul><h2 id="6、HTTPS-握手"><a href="#6、HTTPS-握手" class="headerlink" title="6、HTTPS 握手"></a>6、HTTPS 握手</h2><ul><li>如果用的 HTTPS 协议 在通信前还存在 TLS 的第四次捂手过程</li><li>客户端发送 协议本部好 随机数 加密方法</li><li>服务端确认加密方法后发送 随机数 数字证书</li><li>客户端确认证书后发送 随机数并加密 全部内容的 hash</li><li>服务端解密随机数后发生 全部内容的 hash</li><li>此时双方都有 3 个随机数</li><li>加密生成秘钥</li></ul><h2 id="7、发送-HTTP-请求"><a href="#7、发送-HTTP-请求" class="headerlink" title="7、发送 HTTP 请求"></a>7、发送 HTTP 请求</h2><ul><li>服务端处理请求，返回 HTTP 报文</li></ul><h2 id="8、页面渲染"><a href="#8、页面渲染" class="headerlink" title="8、页面渲染"></a>8、页面渲染</h2><ul><li>解析 HTML 文件构建 DOM 树</li><li>解析 CSS 文件构建 CSSOM 树</li><li>如果遇到 script 标签判断是否同步加载还是异步加载</li><li>DOM 树与 CSSOM 树合成渲染树进行布局</li><li>布局完成后使用浏览器的 UI 接口对页面进行绘制</li></ul><h2 id="9、TCP-第四次握手"><a href="#9、TCP-第四次握手" class="headerlink" title="9、TCP 第四次握手"></a>9、TCP 第四次握手</h2><ul><li>最后一步是 TCP 端口连接的第四次握手过程</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computed和watch的区别</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>其实它只是 this.$watch 这个 API 的一种封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">name</span>(<span class="hljs-params">newName</span>) &#123;...&#125;<br>&#125;<br>&#125;<br><br>---------------------------------------------------------<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-function"><span class="hljs-params">newName</span> =&gt;</span> &#123;...&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听属性初始化"><a href="#监听属性初始化" class="headerlink" title="监听属性初始化"></a>监听属性初始化</h2><p>为什么这么说，我们首先来看下初始化时 watch 属性都做了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;  <span class="hljs-comment">// 初始化所有状态时</span><br>  vm.<span class="hljs-property">_watchers</span> = []  <span class="hljs-comment">// 当前实例watcher集合</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>  <span class="hljs-comment">// 合并后的属性</span><br><br>  ... <span class="hljs-comment">// 其他状态初始化</span><br><br>  <span class="hljs-keyword">if</span>(opts.<span class="hljs-property">watch</span>) &#123;  <span class="hljs-comment">// 如果有定义watch属性</span><br>    <span class="hljs-title function_">initWatch</span>(vm, opts.<span class="hljs-property">watch</span>)  <span class="hljs-comment">// 执行初始化方法</span><br>  &#125;<br>&#125;<br><br>---------------------------------------------------------<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initWatch</span> (vm, watch) &#123;  <span class="hljs-comment">// 初始化方法</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> watch) &#123;  <span class="hljs-comment">// 遍历watch内多个监听属性</span><br>    <span class="hljs-keyword">const</span> handler = watch[key]  <span class="hljs-comment">// 每一个监听属性的值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;  <span class="hljs-comment">// 如果该项的值为数组</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; handler.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-title function_">createWatcher</span>(vm, key, handler[i])  <span class="hljs-comment">// 将每一项使用watcher包装</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">createWatcher</span>(vm, key, handler) <span class="hljs-comment">// 不是数组直接使用watcher</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>---------------------------------------------------------<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWatcher</span> (vm, expOrFn, handler, options) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPlainObject</span>(handler)) &#123; <span class="hljs-comment">// 如果是对象，参数移位</span><br>    options = handler<br>    handler = handler.<span class="hljs-property">handler</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;  <span class="hljs-comment">// 如果是字符串，表示为方法名</span><br>    handler = vm[handler]  <span class="hljs-comment">// 获取methods内的方法</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> vm.$watch(expOrFn, handler, options)  <span class="hljs-comment">// 封装</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先初始化时，会判断并遍历 vm.$options.watch 属性，最终调用vm.$watch</p></blockquote><h2 id="监听属性实现原理"><a href="#监听属性实现原理" class="headerlink" title="监听属性实现原理"></a>监听属性实现原理</h2><p>所以我们来看下$watch 的内部实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">expOrFn, cb, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPlainObject</span>(cb)) &#123;  <span class="hljs-comment">// 如果cb是对象，当手动创建监听属性时</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createWatcher</span>(vm, expOrFn, cb, options)<br>  &#125;<br><br>  options.<span class="hljs-property">user</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// user-watcher的标志位，传入Watcher类中</span><br>  <span class="hljs-keyword">const</span> watcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expOrFn, cb, options)  <span class="hljs-comment">// 实例化user-watcher</span><br><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;  <span class="hljs-comment">// 立即执行</span><br>    cb.<span class="hljs-title function_">call</span>(vm, watcher.<span class="hljs-property">value</span>)  <span class="hljs-comment">// 以当前值立即执行一次回调函数</span><br>  &#125;  <span class="hljs-comment">// watcher.value为实例化后返回的值</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unwatchFn</span> () &#123;  <span class="hljs-comment">// 返回一个函数，执行取消监听</span><br>    watcher.<span class="hljs-title function_">teardown</span>()<br>  &#125;<br>&#125;<br><br>---------------------------------------------------------------<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cc&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">unwatch</span> = <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-function"><span class="hljs-params">newName</span> =&gt;</span> &#123;...&#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unwatch</span>()  <span class="hljs-comment">// 取消监听</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>虽然 watch 内部是使用 this.$watch，当我们还是可以通过 this.$watch 来创建监听的，所以第二个参数 cb 会出现对象的情况。</p></blockquote><ul><li>设置标记 options.user&#x3D;true,表明这是一个 user-watcher。</li><li>再给 watch 设置了 immediate 属性后，会将实例化后得到的值传入回调，并立即执行一次回调函数，这也是 immediate 的实现原理。</li><li>最后的返回值是一个方法，执行后可以取消对该监听属性的监听。接下来我们看看 user-watcher 是如何定义的：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm<br>    vm.<span class="hljs-property">_watchers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 添加到当前实例的watchers内</span><br><br>    <span class="hljs-keyword">if</span>(options) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span> = !!options.<span class="hljs-property">deep</span>  <span class="hljs-comment">// 是否深度监听</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = !!options.<span class="hljs-property">user</span>  <span class="hljs-comment">// 是否是user-wathcer</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span> = !!options.<span class="hljs-property">sync</span>  <span class="hljs-comment">// 是否同步更新</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// // 派发更新的标志位</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb  <span class="hljs-comment">// 回调函数</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;  <span class="hljs-comment">// 如果expOrFn是函数</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-title function_">parsePath</span>(expOrFn)  <span class="hljs-comment">// 如果是字符串对象路径形式，返回闭包函数</span><br>    &#125;<br><br>    ...<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当是 user-watcher 时，Watcher 内部是以上方式实例化的，通常情况下我们是使用字符串的形式创建监听属性，所以首先来看下 parsePath 方法是干什么的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bailRE = <span class="hljs-regexp">/[^\w.$]/</span>; <span class="hljs-comment">// 得是对象路径形式，如info.name</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parsePath</span>(<span class="hljs-params">path</span>) &#123;<br>  <span class="hljs-keyword">if</span> (bailRE.<span class="hljs-title function_">test</span>(path)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不匹配对象路径形式，再见</span><br><br>  <span class="hljs-keyword">const</span> segments = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>); <span class="hljs-comment">// 按照点分割为数组</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-comment">// 闭包返回一个函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; segments.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>      obj = obj[segments[i]]; <span class="hljs-comment">// 依次读取到实例下对象末端的值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>parsePath 方法最终返回一个闭包方法，此时 Watcher 类中的 this.getter 就是一个函数了，再执行 this.get()方法时会将 this.vm 传入到闭包内，补全 Watcher 其他的逻辑：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br><br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-title function_">parsePath</span>(expOrFn)  <span class="hljs-comment">// 返回的方法</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">// 执行get</span><br>  &#125;<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 将当前user-watcher实例赋值给Dep.target，读取时收集它</span><br><br>    <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>)  <span class="hljs-comment">// 将vm实例传给闭包，进行读取操作</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span>) &#123;  <span class="hljs-comment">// 如果有定义deep属性</span><br>      <span class="hljs-title function_">traverse</span>(value)  <span class="hljs-comment">// 进行深度监听</span><br>    &#125;<br><br>    <span class="hljs-title function_">popTarget</span>()<br>    <span class="hljs-keyword">return</span> value  <span class="hljs-comment">// 返回闭包读取到的值，参数immediate使用的就是这里的值</span><br>  &#125;<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为之前初始化已经将状态已经全部都代理到了 this 下，所以读取 this 下的属性即可，比如：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// data的初始化先与watch</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cc&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;info.name&#x27;</span>, <span class="hljs-function"><span class="hljs-params">newName</span> =&gt;</span> &#123;...&#125;)  <span class="hljs-comment">// 何况手动创建</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先读取 this 下的 info 属性，然后读取 info 下的 name 属性。大家注意，这里我们使用了读取这个动词，所以会执行之前包装 data 响应式数据的 get 方法进行依赖收集，将依赖收集到读取到的属性的 dep 里，不过收集的是 user-watcher，get 方法最后返回闭包读取到的值。</p></blockquote><blockquote><p>之后就是当 info.name 属性被重新赋值时，走派发更新的流程，我们这里把和 render-watcher 不同之处做单独的说明，派发更新会执行 Watcher 内的 update 方法内：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br>    ...<br>  &#125;<br><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 执行派发更新</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span>) &#123;  <span class="hljs-comment">// 如果有设置sync为true</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>()  <span class="hljs-comment">// 不走nextTick队列，直接执行</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 否则加入队列，异步执行run()</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAndInvoke</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>)  <span class="hljs-comment">// 传入回调函数</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">getAndInvoke</span>(<span class="hljs-params">cb</span>) &#123;<br>    <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">// 重新求值</span><br><br>    <span class="hljs-keyword">if</span>(value !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> || <span class="hljs-title function_">isObject</span>(value) || <span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span>) &#123;<br>      <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>  <span class="hljs-comment">// 缓存之前的值</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value  <span class="hljs-comment">// 新值</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;  <span class="hljs-comment">// 如果是user-watcher</span><br>        cb.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, value, oldValue)  <span class="hljs-comment">// 在回调内传入新值和旧值</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其实这里的 sync 属性已经没在官网做说明了，不过我们看到源码中还是保留了相关代码。接下来我们看到为什么 watch 的回调内可以得到新值和旧值的原理，因为 cb.call(this.vm, value, oldValue)这句代码的原因，内部将新值和旧值传给了回调函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// watch监听属性示例：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// App组件</span><br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cc&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">name</span>(<span class="hljs-params">newName, oldName</span>) &#123;...&#125;  <span class="hljs-comment">// 派发新值和旧值给回调</span><br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ww&#x27;</span>  <span class="hljs-comment">// 触发name的set</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听属性的-deep-深度监听原理"><a href="#监听属性的-deep-深度监听原理" class="headerlink" title="监听属性的 deep 深度监听原理"></a>监听属性的 deep 深度监听原理</h2><p>之前的 get 方法内有说明，如果有 deep 属性，则执行 traverse 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> seenObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 不重复添加</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-title function_">_traverse</span>(val, seenObjects);<br>  seenObjects.<span class="hljs-title function_">clear</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_traverse</span>(<span class="hljs-params">val, seen</span>) &#123;<br>  <span class="hljs-keyword">let</span> i, keys;<br>  <span class="hljs-keyword">const</span> isA = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(val); <span class="hljs-comment">// val是否是数组</span><br><br>  <span class="hljs-keyword">if</span> (<br>    (!isA &amp;&amp; !<span class="hljs-title function_">isObject</span>(val)) || <span class="hljs-comment">// 如果不是array和object</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(val) || <span class="hljs-comment">// 或者是已经冻结对象</span><br>    val <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">VNode</span><br>  ) &#123;<br>    <span class="hljs-comment">// 或者是VNode实例</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 再见</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (val.<span class="hljs-property">__ob__</span>) &#123;<br>    <span class="hljs-comment">// 只有object和array才有__ob__属性</span><br>    <span class="hljs-keyword">const</span> depId = val.<span class="hljs-property">__ob__</span>.<span class="hljs-property">dep</span>.<span class="hljs-property">id</span>; <span class="hljs-comment">// 手动依赖收集器的id</span><br>    <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(depId)) &#123;<br>      <span class="hljs-comment">// 已经有收集过</span><br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 再见</span><br>    &#125;<br>    seen.<span class="hljs-title function_">add</span>(depId); <span class="hljs-comment">// 没有被收集，添加</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (isA) &#123;<br>    <span class="hljs-comment">// 是array</span><br>    i = val.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-title function_">_traverse</span>(val[i], seen); <span class="hljs-comment">// 递归触发每一项的get进行依赖收集</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 是object</span><br>    keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(val);<br>    i = keys.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-title function_">_traverse</span>(val[keys[i]], seen); <span class="hljs-comment">// 递归触发子属性的get进行依赖收集</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>看着还挺复杂，简单来说 deep 的实现原理就是递归的触发数组或对象的 get 进行依赖收集，因为只有数组和对象才有<strong>ob</strong>属性，也就是我们第七章说明的手动依赖管理器，将它们的依赖收集到 Observer 类里的 dep 内，完成 deep 深度监听。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这里说明了为什么 watch 和 this.$watch 的实现是一致的，以及简单解释它的原理就是为需要观察的数据创建并收集 user-watcher，当数据改变时通知到 user-watcher 将新值和旧值传递给用户自己定义的回调函数。最后分析了定义 watch 时会被使用到的三个参数：sync、immediate、deep 它们的实现原理。简单说明它们的实现原理就是：sync 是不将 watcher 加入到 nextTick 队列而同步的更新、immediate 是立即以得到的值执行一次回调函数、deep 是递归的对它的子值进行依赖收集。</p></blockquote><h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>计算属性不是 API，但它是 Watcher 类,也是最复杂的一种实例化的使用。</p><p>分析计算属性为何可以做到当依赖发生变化时才会重新计算，否则数据被缓存。</p><p>计算属性的值也可以是对象，这个对象需要传入 get 和 set 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">newName</span>: &#123;  <span class="hljs-comment">// 不分析这种了~</span><br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;...&#125;,  <span class="hljs-comment">// 内部会采用get属性为计算属性的值</span><br>      <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>) &#123;...&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算属性初始化"><a href="#计算属性初始化" class="headerlink" title="计算属性初始化"></a>计算属性初始化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;  <span class="hljs-comment">// 初始化所有状态时</span><br>  vm.<span class="hljs-property">_watchers</span> = []  <span class="hljs-comment">// 当前实例watcher集合</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>  <span class="hljs-comment">// 合并后的属性</span><br><br>  ... <span class="hljs-comment">// 其他状态初始化</span><br><br>  <span class="hljs-keyword">if</span>(opts.<span class="hljs-property">computed</span>) &#123;  <span class="hljs-comment">// 如果有定义计算属性</span><br>    <span class="hljs-title function_">initComputed</span>(vm, opts.<span class="hljs-property">computed</span>)  <span class="hljs-comment">// 进行初始化</span><br>  &#125;<br>  ...<br>&#125;<br><br>---------------------------------------------------------------------------<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span>(<span class="hljs-params">vm, computed</span>) &#123;<br>  <span class="hljs-keyword">const</span> watchers = vm.<span class="hljs-property">_computedWatchers</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 创建一个纯净对象</span><br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;<br>    <span class="hljs-keyword">const</span> getter = computed[key]  <span class="hljs-comment">// computed每项对应的回调函数</span><br><br>    watchers[key] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, getter, noop, &#123;<span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>&#125;)  <span class="hljs-comment">// 实例化computed-watcher</span><br><br>    ...<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算属性实现原理"><a href="#计算属性实现原理" class="headerlink" title="计算属性实现原理"></a>计算属性实现原理</h2><blockquote><p>这里还是按照惯例，将定义的 computed 属性的每一项使用 Watcher 类进行实例化，不过这里是按照 computed-watcher 的形式，来看下如何实例化的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_watchers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>);<br><br>    <span class="hljs-keyword">if</span> (options) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = !!options.<span class="hljs-property">lazy</span>; <span class="hljs-comment">// 表示是computed</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>; <span class="hljs-comment">// dirty为标记位，表示是否对computed计算</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn; <span class="hljs-comment">// computed的回调函数</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的 App 组件在执行 extend 创建子组件的构造函数时，已经将 key 挂载到 vm 的原型中了，不过之前也是执行的 defineComputed 方法，所以不妨碍我们看它做了什么：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span>(<span class="hljs-params">target, key</span>) &#123;<br>  ...<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">get</span>: <span class="hljs-title function_">createComputedGetter</span>(key),<br>    <span class="hljs-attr">set</span>: noop<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个方法的作用就是让 computed 成为一个响应式数据，并定义它的 get 属性，也就是说当页面执行渲染访问到 computed 时，才会触发 get 然后执行 createComputedGetter 方法，所以之前的点到为止再这里会续上，看下 get 方法是怎么定义的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span> (key) &#123; <span class="hljs-comment">// 高阶函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 返回函数</span><br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]<br>    <span class="hljs-comment">// 原来this还可以这样用，得到key对应的computed-watcher</span><br><br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) &#123;  <span class="hljs-comment">// 在实例化watcher时为true，表示需要计算</span><br>        watcher.evaluate()  <span class="hljs-comment">// 进行计算属性的求值</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;  <span class="hljs-comment">// 当前的watcher，这里是页面渲染触发的这个方法，所以为render-watcher</span><br>        watcher.<span class="hljs-title function_">depend</span>()  <span class="hljs-comment">// 收集当前watcher</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span>  <span class="hljs-comment">// 返回求到的值或之前缓存的值</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>------------------------------------------------------------------------------------<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  ...<br><br>  evaluate () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">//  计算属性求值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 表示计算属性已经计算，不需要再计算</span><br>  &#125;<br><br>  depend () &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>  <span class="hljs-comment">// deps内是计算属性内能访问到的响应式数据的dep的数组集合</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>()  <span class="hljs-comment">// 让每个dep收集当前的render-watcher</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的变量 watcher 就是之前 computed 对应的 computed-watcher 实例，接下来会执行 Watcher 类专门为计算属性定义的两个方法，在执行 evaluate 方法进行求值的过程中又会触发 computed 内可以访问到的响应式数据的 get，它们会将当前的 computed-watcher 作为依赖收集到自己的 dep 里，计算完毕之后将 dirty 置为 false，表示已经计算过了。</p></blockquote><blockquote><p>然后执行 depend 让计算属性内的响应式数据订阅当前的 render-watcher，所以 computed 内的响应式数据会收集 computed-watcher 和 render-watcher 两个 watcher，当 computed 内的状态发生变更触发 set 后，首先通知 computed 需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到 computed 计算后的值，最后渲染到页面。</p></blockquote><blockquote><p>当 computed 内的响应式数据变更后触发的通知：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  ...<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 当computed内的响应式数据触发set后</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">diray</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 通知computed需要重新计算了</span><br>    &#125;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最后还是以一个示例结合流程图来帮大家理清楚这里的逻辑：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">manName</span>: <span class="hljs-string">&#x27;cc&#x27;</span>,<br>      <span class="hljs-attr">womanName</span>: <span class="hljs-string">&#x27;ww&#x27;</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">newName</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">manName</span> + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">womanName</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">changeName</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">manName</span> = <span class="hljs-string">&#x27;ss&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote><p>为什么计算属性有缓存功能？因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值；为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？因为内部的响应式数据会收集 computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值。</p></blockquote><p><a href="https://juejin.cn/post/6844903926819454983#heading-0">查看原文</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的一些面试题</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h1><blockquote><p>老常规第一问</p></blockquote><ul><li>Vue2：beforeCreate &#x3D;&gt; created &#x3D;&gt; beforeMount &#x3D;&gt; mounted &#x3D;&gt; beforeUpdate &#x3D;&gt; updated &#x3D;&gt; beforeDestroy &#x3D;&gt; destroyed</li><li>Vue3：setup &#x3D;&gt; onBeforeMount &#x3D;&gt; onMount &#x3D;&gt; onBeforeUpdate &#x3D;&gt; onUpdated &#x3D;&gt; onBeforeUnmount &#x3D;&gt; onUnmounted</li></ul><blockquote><p>keep-alive</p></blockquote><ul><li>Vue2：activated 、deactivated</li><li>Vue3：onActivated 、onDeactivated</li></ul><blockquote><p>捕获一个来自子孙组件的异常</p></blockquote><ul><li>vue2：errorCaptured</li><li>vue3：onErrorCaptured</li></ul><h1 id="父子生命周期的顺序"><a href="#父子生命周期的顺序" class="headerlink" title="父子生命周期的顺序"></a>父子生命周期的顺序</h1><p>子组件先挂载，然后父组件，更新也类似</p><h1 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h1><p>v-model 是 vue 的语法糖</p><p>input[text&#x2F;number&#x2F;password]、textarea 元素使用的 value 属性和 input 事件</p><p>input[checkbox&#x2F;radio]元素使用的 checked 属性和 change 事件</p><p>select 元素将 value 作为 prop 并将 change 作为事件</p><h1 id="为什么-data-是个函数"><a href="#为什么-data-是个函数" class="headerlink" title="为什么 data 是个函数"></a>为什么 data 是个函数</h1><p>因为组件会被复用需要保证唯一性</p><h1 id="Keep-alive-的了解"><a href="#Keep-alive-的了解" class="headerlink" title="Keep-alive 的了解"></a>Keep-alive 的了解</h1><p>keep-alive 是 vue 内部的组件 可以使被包含的组件保留状态，避免重新渲染</p><ol><li>一般结合路由和动态组件一起使用，用于缓存组件</li><li>提供的 include 和 exclude 属性<ul><li>include &#x3D;&gt; 只有匹配的会缓存</li><li>exclude &#x3D;&gt; 匹配的不会缓存 优先级比 include 高</li></ul></li><li>对象两个特殊钩子函数 activated 和 deactivated</li></ol><h1 id="computed-和-watch-的区别和运用场景"><a href="#computed-和-watch-的区别和运用场景" class="headerlink" title="computed 和 watch 的区别和运用场景"></a>computed 和 watch 的区别和运用场景</h1><ul><li>computed:计算属性,有缓存,当我们需要进行数值计算，并且依赖于其他数据时使用</li><li>watch:监听,当我们需要异步或开销较大的操作时使用,可以根据需要限制我们操作的频次</li></ul><a href="/xiaolanchong.githug.io/2023/04/08/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/" title="computed和watch的区别">computed和watch的区别</a><h1 id="聊聊-nextTick"><a href="#聊聊-nextTick" class="headerlink" title="聊聊 nextTick"></a>聊聊 nextTick</h1><ol><li>把回调函数放入 callbacks 等待执行</li><li>将执行函数放入微任务或宏任务中<blockquote><p>为什么是微任务或宏任务？<br>对当前环境进行了降级处理 Promise &#x3D;&gt; MutationObserver &#x3D;&gt; setImmediate &#x3D;&gt; setTimeout (1、2 微任务 3、4 宏任务)</p></blockquote></li><li>事件循环到微任务或宏任务，执行函数依次执行 callbacks 中的回调</li></ol><h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><blockquote><p>为什么使用 render 函数？</p></blockquote><p>VUE 推荐在绝大多数情况下使用 template 来创建我们的 HTML。然而在一些场景中，我们真的需要 JavaScript 的完全编程的能力，这就是 render 函数，它比 template 更接近编译器。（这是官方的话）<br>简单来说，我们为什么要使用 render 函数呢？？ 便是因为我们最经常使用的一个引入。</p><blockquote><p>render 函数的解析</p></blockquote><p>render 函数即渲染函数，它是个函数，它的参数 createElement 也是个函数。</p><p>createElement 有三个参数</p><ol><li>一个 HTML 标签字符串 必选</li><li>一个包含模板相关属性的数据对象 可选</li><li>子虚拟节点 可选</li></ol><p><a href="https://blog.csdn.net/m0_59722204/article/details/126907040">查看原文</a></p><h1 id="v-show-与-v-if-的区别"><a href="#v-show-与-v-if-的区别" class="headerlink" title="v-show 与 v-if 的区别"></a>v-show 与 v-if 的区别</h1><ul><li>v-if 是条件渲染 确保在切换过程中条件块内的事件监听器和子组件适当地被销毁重建</li><li>v-show 元素总会被渲染，且只是简单地基于 display 属性进行切换</li></ul><h1 id="Class-与-Style-如何动态绑定"><a href="#Class-与-Style-如何动态绑定" class="headerlink" title="Class 与 Style 如何动态绑定"></a>Class 与 Style 如何动态绑定</h1><ul><li>对象语法</li><li>数组语法</li></ul><h1 id="vue-router-路由模式有几种"><a href="#vue-router-路由模式有几种" class="headerlink" title="vue-router 路由模式有几种"></a>vue-router 路由模式有几种</h1><ol><li>hash location.hash 向服务端发出请求是 hash 部分不会被发送</li><li>history HTML5 提供了 History API 来实现 URL 的变化<ul><li>history.pushState()</li><li>history.repalceState()</li></ul></li><li>abstract 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ol><h1 id="SPA-单页的理解-优缺点"><a href="#SPA-单页的理解-优缺点" class="headerlink" title="SPA 单页的理解 优缺点"></a>SPA 单页的理解 优缺点</h1><ul><li>SPA 仅在页面初始化时加载相应的 html、js、css 等</li><li>SPA 不会因为用户的操作而进行页面的重新加载和跳转；取而代之的是利用路由机制实现页面内容的变化</li></ul><blockquote><p>优点：</p></blockquote><ol><li>用户体验好、快、内容的改变不需重新加载整个页面，避免不必要的跳转和重新渲染</li><li>SPA 相对服务器压力小；</li><li>前后端分离，架构清晰，前端负责交互逻辑，后端提供相应的数据接口；</li></ol><blockquote><p>缺点：</p></blockquote><ol><li>首屏加载等待问题；</li><li>SEO 难度大</li></ol><blockquote><p>SPA</p></blockquote><ol><li>CSR 客户端渲染&#x3D;&gt;当前主流模式</li><li>SSR 服务端渲染&#x3D;&gt;能较好的解决 SEO 的问题</li><li>Prerender 预渲染&#x3D;&gt;打包阶段预先生成页面</li><li>同构 两者的结合&#x3D;&gt; 参考框架 Nuxt.js</li></ol><div class="note note-warning">            <p>注：SSR 需要路由需要使用 history 模式</p>          </div>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件间的通讯方式</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-组件间的通讯方式"><a href="#Vue-组件间的通讯方式" class="headerlink" title="Vue 组件间的通讯方式"></a>Vue 组件间的通讯方式</h1><div class="note note-warning">            <p>Vue 是单项数据流</p>          </div><h2 id="父组件向子组件传递-props"><a href="#父组件向子组件传递-props" class="headerlink" title="父组件向子组件传递 props"></a>父组件向子组件传递 props</h2><p>父组件通过 props 向子组件传递数据，子组件通过 $emit 和父组件通信</p><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msg&quot;</span> <span class="hljs-attr">:fn</span>=<span class="hljs-string">&quot;changeMsg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Function</span></span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fn(&#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="子组件向父组件传递-emit"><a href="#子组件向父组件传递-emit" class="headerlink" title="子组件向父组件传递 $emit"></a>子组件向父组件传递 $emit</h2><p>$emit 的特点</p><ul><li>$emit 绑定一个自定义事件，当事件被执行的时候会将参数传递给父组件，而父组件通过 v-on 监听并接受参数</li></ul><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-attr">fn</span>=<span class="hljs-string">&quot;changeMsg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;fn&#x27;</span>]);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;fn&#x27;, &#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="兄弟组件传递"><a href="#兄弟组件传递" class="headerlink" title="兄弟组件传递"></a>兄弟组件传递</h2><ol><li>兄弟组件间通信可以借助父组件交互</li></ol><h2 id="ref-x2F-refs"><a href="#ref-x2F-refs" class="headerlink" title="ref &#x2F; $refs"></a>ref &#x2F; $refs</h2><p>该方法也是实现父子组件通信的</p><p>ref: 该属性用在子组件上，他指向子组件的实例，可以通过实例来访问组件的数据和方法</p><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-comment">// vue3需要主动暴露</span></span><br><span class="language-javascript">  <span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">    msg,</span><br><span class="language-javascript">    changeMsg</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> refChild = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// onMounted后才能获取到</span></span><br><span class="language-javascript">    refChild.<span class="hljs-property">value</span>?.<span class="hljs-title function_">changeMsg</span>(str);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;refChild&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg(&#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="依赖注入-provide-x2F-inject"><a href="#依赖注入-provide-x2F-inject" class="headerlink" title="依赖注入 provide &#x2F; inject"></a>依赖注入 provide &#x2F; inject</h1><p>该方法就是 vue 中的依赖主人，该方法用于父子&#x2F;祖孙组件间的通信</p><p>provide&#x2F;inject 是 vue 提供的两个钩子</p><ul><li>provide 用来发送数据或方法</li><li>inject 用来接受数据或方法</li></ul><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;msg&#x27;</span>, msg);</span><br><span class="language-javascript">  <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;changeMsg&#x27;</span>, changeMsg);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref, inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> changeMsg = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;changeMsg&#x27;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg(&#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="parent-x2F-children"><a href="#parent-x2F-children" class="headerlink" title="$parent &#x2F; $children"></a>$parent &#x2F; $children</h2><blockquote><p>$parent</p></blockquote><blockquote><p>$children（vue3 已移除）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h2 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h2><h2 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h2><h2 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs $listeners"></a>$attrs $listeners</h2>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diff算法</title>
    <link href="/xiaolanchong.githug.io/2023/04/07/Diff%E7%AE%97%E6%B3%95/"/>
    <url>/xiaolanchong.githug.io/2023/04/07/Diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、首先什么是虚拟-DOM"><a href="#1、首先什么是虚拟-DOM" class="headerlink" title="1、首先什么是虚拟 DOM?"></a>1、首先什么是虚拟 DOM?</h2><p>虚拟 DOM 就是一个普通的 JS 对象，用来描述真实的 DOM 结构的对象</p><h2 id="2、什么事-Diff-算法？"><a href="#2、什么事-Diff-算法？" class="headerlink" title="2、什么事 Diff 算法？"></a>2、什么事 Diff 算法？</h2><p>diff 算法是用来比较虚拟节点、并返回一个 patch 对象，用来存储新旧节点不同的地方<br>简单来说：diff 的过程就是调用 patch 函数，比较新旧节点，边比较边给 DOM 打补丁</p><blockquote><p>那么 diff 算法有什么特征呢？</p></blockquote><ol><li>比较只会发生在同层级进行，不会跨层级比较</li><li>diff 比较的过程中，循环从两边向中间比较</li></ol><blockquote><p>diff 算法的步骤</p></blockquote><ul><li>用 js 对象结构表示 ODM 的结构，然后用这个树结果创建一个真实的 DOM，插入到页面中</li><li>当状态发生变化时，重新构造一个新的对象树</li><li>新旧对象树进行比较（diff）,记录差异变化</li><li>把记录的差异应用到真实 DOM 树上（patch），完成视图的更新</li></ul><blockquote><p>原理分析</p></blockquote><p>当数据发生变化时，set 方法会调用 Dep.notify 通知所以得订阅者 Watcher,订阅者会调用 patch 给真实的 DOM 打补丁，更新响应的视图</p><h2 id="Vue2-中的-Diff"><a href="#Vue2-中的-Diff" class="headerlink" title="Vue2 中的 Diff"></a>Vue2 中的 Diff</h2><blockquote><p>双端 diff 算法</p></blockquote><ol><li>当数据发生变化时，订阅者 Watcher 会调用 patch 给真实 DOM 打补丁</li><li>通过 SameVnode(oldVode, newVode)进行判断，相同时则调用 patchVnode 方法</li><li>patchVnode<ul><li>判断文本节点，直接设置文本</li><li>子节点比较<br>一方不存在是，直接删除或创建<br>两者都有时，执行 updateChildren 函数比较子节点</li></ul></li><li>updateChildren<ul><li>设置新旧 vnode 的头尾指针</li><li>新旧头尾进行比较，循环先中间靠拢（四个角向中间靠拢比较）<br>根据情况调用 patchVnode 进行 patch 重复流程、调用 createElem 创建一个新的节点<br>从哈希表寻找 key 一致的 vNode 节点再分情况操作</li></ul></li></ol><h2 id="vue3-中的-Diff"><a href="#vue3-中的-Diff" class="headerlink" title="vue3 中的 Diff"></a>vue3 中的 Diff</h2><blockquote><p>快速 diff 算法</p></blockquote><p>Vue3 在真正的 diff 之前会执行一段“预处理”的前置操作，目的是先把科一直接排除的项直接去掉</p><ol><li>对比新旧节点头部相同指针的节点，相同则进行 diff，不同就跳转下一步</li><li>新旧节点尾部指针指向的节点，相同则进行 diff，不同就跳转下一步</li><li>此时剩余新旧节点可能存在乱序、一移除、新创建的情况，进行特殊处理来更新<ul><li>增删节点</li><li>diff<br>首先根据新节点剩余内容，跟 key 创建一个 map 映射<br>最长递增子序列 为减少 dom 的操作</li></ul></li></ol><blockquote><p>vue3 牺牲了一部分 js 性能，换来了 dom 渲染的性能</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Diff</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向数据绑定</title>
    <link href="/xiaolanchong.githug.io/2023/04/07/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/xiaolanchong.githug.io/2023/04/07/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h2><p>简单来说就是数据层和视图层之间实现相互绑定<br>也就是说视图发生变化数据会发生变化，同理数据发生变化视图也会发生相应的改变</p><h2 id="双向数据绑定的原理（MVVM）"><a href="#双向数据绑定的原理（MVVM）" class="headerlink" title="双向数据绑定的原理（MVVM）"></a>双向数据绑定的原理（MVVM）</h2><ul><li>M 数据层</li><li>V 视图层</li><li>VM 业务处理层（核心层）<ul><li>监听器 Obsever 对所有数据的属性进行监听</li><li>解析器 Compiler 对每个元素节点进行解析</li></ul></li></ul><h2 id="如何实现双向绑定"><a href="#如何实现双向绑定" class="headerlink" title="如何实现双向绑定"></a>如何实现双向绑定</h2><ul><li>初始化 对 data 执行响应处理 Obsever</li><li>同时对模版执行编译从 data 中获取动态数据，并初始化视图 Compiler</li><li>同时定义一个更新函数和 Watcher 将来对象数据发生变化时 Watcher 会调用更新函数</li><li>由于 data 的某个属性 key 在视图中可能出现多次，所以每个 key 都需要有一个 Dep 来管理多个 Watcher</li><li>将来 data 中数据一旦发生变化，会首先找到对应的 Dep 通知所有的 Watcher 执行更新函数</li></ul><p><img src="/xiaolanchong.githug.io/images/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" alt="双向数据绑定原理"></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
