<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跟随系统主题</title>
    <link href="/xiaolanchong.githug.io/2023/07/02/%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98/"/>
    <url>/xiaolanchong.githug.io/2023/07/02/%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="跟随系统主题"><a href="#跟随系统主题" class="headerlink" title="跟随系统主题"></a>跟随系统主题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> media = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">matchMedia</span>(<span class="hljs-string">&#x27;(prefers-color-scheme:light)&#x27;</span>);<br><span class="hljs-comment">// or</span><br><span class="hljs-comment">// const media = window.matchMedia(&#x27;(prefers-color-scheme:dark)&#x27;)</span><br><br><span class="hljs-comment">// 判断是否为亮主题</span><br><span class="hljs-keyword">if</span> (media.<span class="hljs-property">matchs</span>) &#123;<br>  <span class="hljs-comment">// 匹配到暗主题</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 没有匹配到暗主题</span><br>&#125;<br><br><span class="hljs-comment">// 上面操作只会在页面加载时才会生效，因此，需要给media添加事件监听器</span><br>media.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">matches</span>) &#123;<br>    <span class="hljs-comment">//   </span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// </span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2465. 不同的平均值数目-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/2465.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/2465.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="不同的平均值数目-EASY"><a href="#不同的平均值数目-EASY" class="headerlink" title="不同的平均值数目-EASY"></a>不同的平均值数目-EASY</h1><p><a href="https://leetcode.cn/problems/apply-operations-to-an-array/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> applyOperations = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] === nums[i + <span class="hljs-number">1</span>]) &#123;<br>      nums[i] *= <span class="hljs-number">2</span>;<br>      nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>      [nums[i], nums[j]] = [nums[j], nums[i]];<br>      j++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2460. 对数组执行操作-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/2460.%20%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/2460.%20%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="对数组执行操作-EASY"><a href="#对数组执行操作-EASY" class="headerlink" title="对数组执行操作-EASY"></a>对数组执行操作-EASY</h1><p><a href="https://leetcode.cn/problems/apply-operations-to-an-array/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> applyOperations = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] === nums[i + <span class="hljs-number">1</span>]) &#123;<br>      nums[i] *= <span class="hljs-number">2</span>;<br>      nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>      [nums[i], nums[j]] = [nums[j], nums[i]];<br>      j++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2352. 相等行列对-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/2352.%20%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/2352.%20%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="相等行列对-MEDIUM"><a href="#相等行列对-MEDIUM" class="headerlink" title="相等行列对-MEDIUM"></a>相等行列对-MEDIUM</h1><p><a href="https://leetcode.cn/problems/equal-row-and-column-pairs/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> equalPairs = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> n = grid.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">const</span> val = grid[i].<span class="hljs-title function_">toString</span>();<br>    map.<span class="hljs-title function_">set</span>(val, (map.<span class="hljs-title function_">get</span>(val) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">var</span> val = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      val.<span class="hljs-title function_">push</span>(grid[j][i]);<br>    &#125;<br>    res += map.<span class="hljs-title function_">get</span>(val.<span class="hljs-title function_">toString</span>()) || <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2611. 老鼠和奶酪-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/2611.%20%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/2611.%20%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="老鼠和奶酪-MEDIUM"><a href="#老鼠和奶酪-MEDIUM" class="headerlink" title="老鼠和奶酪-MEDIUM"></a>老鼠和奶酪-MEDIUM</h1><p><a href="https://leetcode.cn/problems/mice-and-cheese/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> miceAndCheese = <span class="hljs-keyword">function</span> (<span class="hljs-params">reward1, reward2, k</span>) &#123;<br>  <span class="hljs-keyword">const</span> n = reward1.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">var</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">var</span> diff = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    ans += reward2[i];<br>    diff.<span class="hljs-title function_">push</span>(reward1[i] - reward2[i]);<br>  &#125;<br>  diff = diff.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>    ans += diff[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2496. 数组中字符串的最大值-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/2496.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/2496.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="数组中字符串的最大值-EASY"><a href="#数组中字符串的最大值-EASY" class="headerlink" title="数组中字符串的最大值-EASY"></a>数组中字符串的最大值-EASY</h1><p><a href="https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maximumValue = <span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> str = strs[i];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(str))) &#123;<br>      res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, str.<span class="hljs-property">length</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title class_">Number</span>(str));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>29. 两数相除-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="两数相除-MEDIUM"><a href="#两数相除-MEDIUM" class="headerlink" title="两数相除-MEDIUM"></a>两数相除-MEDIUM</h1><p><a href="https://leetcode.cn/problems/divide-two-integers/">力扣题目</a></p><h1 id="方法一-迭代法"><a href="#方法一-迭代法" class="headerlink" title="方法一 迭代法"></a>方法一 迭代法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> divide = <span class="hljs-keyword">function</span> (<span class="hljs-params">dividend, divisor</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX</span> = <span class="hljs-number">2147483647</span>; <span class="hljs-comment">// 2^31-1</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN</span> = -<span class="hljs-number">2147483648</span>; <span class="hljs-comment">// -2^31</span><br>  <span class="hljs-keyword">if</span> (dividend == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dividend;<br>  <span class="hljs-keyword">if</span> (divisor == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dividend &lt;= <span class="hljs-variable constant_">MIN</span> ? <span class="hljs-variable constant_">MAX</span> : -dividend;<br>  <span class="hljs-keyword">let</span> minus = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否是负数</span><br>  <span class="hljs-comment">// dividend, divisor都处理成负数计算</span><br>  <span class="hljs-keyword">if</span> (dividend &gt; <span class="hljs-number">0</span>) &#123;<br>    dividend = -dividend;<br>    minus = !minus;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (divisor &gt; <span class="hljs-number">0</span>) &#123;<br>    divisor = -divisor;<br>    minus = !minus;<br>  &#125;<br>  <span class="hljs-keyword">let</span> quotient = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (dividend &lt;= divisor) &#123;<br>    dividend -= divisor;<br>    quotient++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> minus ? -quotient : quotient;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-类二分"><a href="#方法二-类二分" class="headerlink" title="方法二 类二分"></a>方法二 类二分</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>与迭代法的区别就在于优化迭代的步数</p></blockquote><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> divide = <span class="hljs-keyword">function</span> (<span class="hljs-params">dividend, divisor</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX</span> = <span class="hljs-number">2147483647</span>; <span class="hljs-comment">// 2^31-1</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN</span> = -<span class="hljs-number">2147483648</span>; <span class="hljs-comment">// -2^31</span><br>  <span class="hljs-keyword">if</span> (dividend == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dividend;<br>  <span class="hljs-keyword">if</span> (divisor == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dividend &lt;= <span class="hljs-variable constant_">MIN</span> ? <span class="hljs-variable constant_">MAX</span> : -dividend;<br>  <span class="hljs-keyword">let</span> minus = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否是负数</span><br>  <span class="hljs-comment">// dividend, divisor都处理成负数计算</span><br>  <span class="hljs-keyword">if</span> (dividend &gt; <span class="hljs-number">0</span>) &#123;<br>    dividend = -dividend;<br>    minus = !minus;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (divisor &gt; <span class="hljs-number">0</span>) &#123;<br>    divisor = -divisor;<br>    minus = !minus;<br>  &#125;<br>  <span class="hljs-keyword">let</span> quotient = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (dividend &lt;= divisor) &#123;<br>    <span class="hljs-keyword">let</span> tempQuotient = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> tempDivisor = divisor;<br>    <span class="hljs-keyword">while</span> (dividend &lt;= tempDivisor + tempDivisor) &#123;<br>      tempDivisor += tempDivisor;<br>      tempQuotient += tempQuotient;<br>    &#125;<br>    dividend -= tempDivisor;<br>    quotient += tempQuotient;<br>  &#125;<br>  <span class="hljs-keyword">return</span> minus ? -quotient : quotient;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31. 下一个排列-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="下一个排列-MEDIUM"><a href="#下一个排列-MEDIUM" class="headerlink" title="下一个排列-MEDIUM"></a>下一个排列-MEDIUM</h1><p><a href="https://leetcode.cn/problems/next-permutation/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>下一个排列 是指其整数的下一个字典序更大的排列，所以本题就是寻找下一个最下小排序</li><li>nums[i+1]&gt;nums[i] 寻找到i的位置</li><li>在[i, len-1]中选择最小的&gt;nums[i]的数并交互得到新的大于nums的排序</li><li>然后[i+1,len-1]的范围进行升序得到最小大于nums的排序</li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> nextPermutation = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> i = len - <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>    i--;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">let</span> j = len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>      j--;<br>    &#125;<br>    [nums[i], nums[j]] = [nums[j], nums[i]];<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> l = i + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> r = len - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-comment">// 由于[l,r]范围内本身就是降序的所以只需要进行翻转就可以得到升序数组</span><br>    [nums[l], nums[r]] = [nums[r], nums[l]];<br>    l++;<br>    r--;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32. 最长有效括号-HEAD</title>
    <link href="/xiaolanchong.githug.io/2023/06/23/subject/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-HEAD/"/>
    <url>/xiaolanchong.githug.io/2023/06/23/subject/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-HEAD/</url>
    
    <content type="html"><![CDATA[<h1 id="最长有效括号-HEAD"><a href="#最长有效括号-HEAD" class="headerlink" title="最长有效括号-HEAD"></a>最长有效括号-HEAD</h1><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/">力扣题目</a></p><h1 id="方法一-栈"><a href="#方法一-栈" class="headerlink" title="方法一 栈"></a>方法一 栈</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>为什么起始栈是[-1] 主要是方便计算<blockquote><p>例如“()”  i-stack[stack.length-1] &#x3D;&gt; i-(-1) &#x3D;&#x3D; 2;</p></blockquote></li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestValidParentheses = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">const</span> stack = [-<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>      stack.<span class="hljs-title function_">push</span>(i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      stack.<span class="hljs-title function_">pop</span>();<br>      <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span>) &#123;<br>        max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, i - stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        stack.<span class="hljs-title function_">push</span>(i);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1156. 单字符重复子串的最大长度-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/03/subject/1156.%20%E5%8D%95%E5%AD%97%E7%AC%A6%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/03/subject/1156.%20%E5%8D%95%E5%AD%97%E7%AC%A6%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="单字符重复子串的最大长度-MEDIUM"><a href="#单字符重复子串的最大长度-MEDIUM" class="headerlink" title="单字符重复子串的最大长度-MEDIUM"></a>单字符重复子串的最大长度-MEDIUM</h1><p><a href="https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/">力扣题目</a></p><h1 id="方法一-滑动窗口"><a href="#方法一-滑动窗口" class="headerlink" title="方法一 滑动窗口"></a>方法一 滑动窗口</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先确认个字母的总长度</li><li>根据规则 最多只能交互一次, 所以连续字符串最多中间只能存在一个不同的字符串</li><li>两段长度相加如果小于字母的总长度，说明有可交互中间不同字符串的存在，最终长度 +1</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxRepOpt1 = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> k = text[i];<br>    count.<span class="hljs-title function_">set</span>(k, (count.<span class="hljs-title function_">get</span>(k) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-property">length</span>; ) &#123;<br>    <span class="hljs-keyword">let</span> curr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> k = text[i];<br>    <span class="hljs-comment">// 计算连续字符串长度</span><br>    <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k == text[j]) &#123;<br>      j++;<br>    &#125;<br>    curr += j - i;<br>    <span class="hljs-comment">// 优化循环 跳过连续部分</span><br>    i = j;<br><br>    <span class="hljs-comment">// 计算间隔一位后 连续的子串长度</span><br>    <span class="hljs-keyword">let</span> m = j + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k == text[m]) &#123;<br>      m++;<br>    &#125;<br>    curr += m - j - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (curr &lt; count.<span class="hljs-title function_">get</span>(k)) &#123;<br>      curr += <span class="hljs-number">1</span>;<br>    &#125;<br>    max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(curr, max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2451. 差值数组不同的字符串-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/06/03/subject/2451.%20%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/06/03/subject/2451.%20%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="差值数组不同的字符串-EASY"><a href="#差值数组不同的字符串-EASY" class="headerlink" title="差值数组不同的字符串-EASY"></a>差值数组不同的字符串-EASY</h1><p><a href="https://leetcode.cn/problems/odd-string-difference/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>该题是让我们计算差值，既然是差值那我们应该想到的是转数字，那字母如何转数字呢？</li><li>目前想到两种方法 <ul><li>一种是创建一个字母与数字的映射表</li><li>第二种是转换成 Unicode</li></ul></li><li>我们使用第二种方法，利用 charCode 或 charCodeAt 把字母转换成 Unicode 进行计算</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getDiff = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = word.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    diff[i] = word.<span class="hljs-title function_">charCodeAt</span>(i + <span class="hljs-number">1</span>) - word.<span class="hljs-title function_">charCodeAt</span>(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> diff.<span class="hljs-title function_">toString</span>();<br>&#125;;<br><span class="hljs-keyword">var</span> oddString = <span class="hljs-keyword">function</span> (<span class="hljs-params">words</span>) &#123;<br>  <span class="hljs-keyword">let</span> diff1 = <span class="hljs-title function_">getDiff</span>(words[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">let</span> diff2 = <span class="hljs-title function_">getDiff</span>(words[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">if</span> (diff1 == diff2) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; words.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (diff1 != <span class="hljs-title function_">getDiff</span>(words[i])) &#123;<br>        <span class="hljs-keyword">return</span> words[i];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> diff1 == <span class="hljs-title function_">getDiff</span>(words[<span class="hljs-number">2</span>]) ? words[<span class="hljs-number">1</span>] : words[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1439. 有序矩阵中的第 k 个最小数组和-HARD</title>
    <link href="/xiaolanchong.githug.io/2023/06/03/subject/1439.%20%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%AC%AC%20k%20%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E5%92%8C-HARD/"/>
    <url>/xiaolanchong.githug.io/2023/06/03/subject/1439.%20%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%AC%AC%20k%20%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E5%92%8C-HARD/</url>
    
    <content type="html"><![CDATA[<h1 id="有序矩阵中的第-k-个最小数组和-HARD"><a href="#有序矩阵中的第-k-个最小数组和-HARD" class="headerlink" title="有序矩阵中的第 k 个最小数组和-HARD"></a>有序矩阵中的第 k 个最小数组和-HARD</h1><p><a href="https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 暴力解法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span> (<span class="hljs-params">mat, k</span>) &#123;<br>  <span class="hljs-keyword">let</span> res_arr = [<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; mat.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> new_arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; mat[i].<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> res_arr) &#123;<br>        new_arr.<span class="hljs-title function_">push</span>(key + mat[i][j]);<br>      &#125;<br>    &#125;<br>    new_arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">if</span> (k &lt; new_arr.<span class="hljs-property">length</span>) &#123;<br>      res_arr = new_arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, k);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res_arr = new_arr;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res_arr[k - <span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1093. 大样本统计-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/03/subject/1093.%20%E5%A4%A7%E6%A0%B7%E6%9C%AC%E7%BB%9F%E8%AE%A1-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/03/subject/1093.%20%E5%A4%A7%E6%A0%B7%E6%9C%AC%E7%BB%9F%E8%AE%A1-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="大样本统计-MEDIUM"><a href="#大样本统计-MEDIUM" class="headerlink" title="大样本统计-MEDIUM"></a>大样本统计-MEDIUM</h1><p><a href="https://leetcode.cn/problems/statistics-from-a-large-sample/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>这道题相等比较简单，直接逐步处理每个值就可以了</li><li>值得注意的是，中位数分奇偶两种情况</li></ol><blockquote><p>结合奇偶的规律可以把奇偶两种情况合并成<br>left &#x3D; Math.floor((total + 1) &#x2F; 2) right &#x3D; Math.floor((total + 2) &#x2F; 2);</p></blockquote><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> sampleStats = <span class="hljs-keyword">function</span> (<span class="hljs-params">count</span>) &#123;<br>  <span class="hljs-keyword">let</span> minimum = <span class="hljs-number">256</span>; <span class="hljs-comment">//最小</span><br>  <span class="hljs-keyword">let</span> maximum = <span class="hljs-number">0</span>; <span class="hljs-comment">//最大</span><br>  <span class="hljs-keyword">let</span> total = count.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur, <span class="hljs-number">0</span>); <span class="hljs-comment">//总长</span><br>  <span class="hljs-keyword">let</span> left = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((total + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>); <span class="hljs-comment">//中位数</span><br>  <span class="hljs-keyword">let</span> right = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((total + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>); <span class="hljs-comment">//中位数</span><br>  <span class="hljs-keyword">let</span> cat = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数</span><br>  <span class="hljs-keyword">let</span> median = <span class="hljs-number">0</span>; <span class="hljs-comment">//中位</span><br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//总和</span><br>  <span class="hljs-keyword">let</span> mean = <span class="hljs-number">0</span>; <span class="hljs-comment">//平均</span><br>  <span class="hljs-keyword">let</span> mode = <span class="hljs-number">0</span>; <span class="hljs-comment">//最多</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (count[i] != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (minimum == <span class="hljs-number">256</span>) &#123;<br>        minimum = i;<br>      &#125;<br>      maximum = i;<br>    &#125;<br>    sum += i * count[i];<br>    <span class="hljs-keyword">if</span> (count[mode] &lt; count[i]) &#123;<br>      mode = i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cat &lt; left &amp;&amp; count[i] + cat &gt;= left) &#123;<br>      median += i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cat &lt; right &amp;&amp; count[i] + cat &gt;= right) &#123;<br>      median += i;<br>    &#125;<br>    cat += count[i];<br>  &#125;<br>  mean = sum / total;<br>  median = median / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [minimum, maximum, mean, median, mode];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1091. 二进制矩阵中的最短路径-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/03/subject/1091.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/03/subject/1091.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制矩阵中的最短路径-MEDIUM"><a href="#二进制矩阵中的最短路径-MEDIUM" class="headerlink" title="二进制矩阵中的最短路径-MEDIUM"></a>二进制矩阵中的最短路径-MEDIUM</h1><p><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先不考虑边界值，每个位置存在8个方向的可能，对应坐标是 x:-1<del>1 y:-1</del>1</li><li>从坐标[0,0]开始，记录走到当前坐标需要的步骤</li><li>但走出边界 后 位置已被反问过时退出，进入下一循环，否则的把下一位置代码循环依次判断</li><li>当走到[n,n]是返回 dist[n][n]</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> shortestPathBinaryMatrix = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) &#123;<br>  <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> len = grid.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Infinity</span>));<br>  dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> temp = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">while</span> (temp.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> [x, y] = temp.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dx = -<span class="hljs-number">1</span>; dx &lt;= <span class="hljs-number">1</span>; dx++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dy = -<span class="hljs-number">1</span>; dy &lt;= <span class="hljs-number">1</span>; dy++) &#123;<br>        <span class="hljs-keyword">if</span> (x == len - <span class="hljs-number">1</span> &amp;&amp; y == len - <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">return</span> dist[x][y];<br>        &#125;<br>        <span class="hljs-comment">// 边界情况</span><br>        <span class="hljs-keyword">if</span> (x + dx &lt; <span class="hljs-number">0</span> || x + dx &gt;= len || y + dy &lt; <span class="hljs-number">0</span> || y + dy &gt;= len) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 被访问了</span><br>        <span class="hljs-keyword">if</span> (grid[x + dx][y + dy] &gt; <span class="hljs-number">0</span> || dist[x + dx][y + dy] &lt;= dist[x][y] + <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        dist[x + dx][y + dy] = dist[x][y] + <span class="hljs-number">1</span>;<br>        temp.<span class="hljs-title function_">push</span>([x + dx, y + dy]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2039. 网络空闲的时刻-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/03/subject/2039.%20%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/03/subject/2039.%20%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="网络空闲的时刻-MEDIUM"><a href="#网络空闲的时刻-MEDIUM" class="headerlink" title="网络空闲的时刻-MEDIUM"></a>网络空闲的时刻-MEDIUM</h1><p><a href="https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>没太理解</p></blockquote><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> networkBecomesIdle = <span class="hljs-keyword">function</span> (<span class="hljs-params">edges, patience</span>) &#123;<br>  <span class="hljs-keyword">const</span> grah = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 构造无向图</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [x, y] <span class="hljs-keyword">of</span> edges) &#123;<br>    grah.<span class="hljs-title function_">get</span>(x) ? grah.<span class="hljs-title function_">get</span>(x).<span class="hljs-title function_">push</span>(y) : grah.<span class="hljs-title function_">set</span>(x, [y]);<br>    grah.<span class="hljs-title function_">get</span>(y) ? grah.<span class="hljs-title function_">get</span>(y).<span class="hljs-title function_">push</span>(x) : grah.<span class="hljs-title function_">set</span>(y, [x]);<br>  &#125;<br>  <span class="hljs-keyword">const</span> queue = [<span class="hljs-number">0</span>],<br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>,<br>    distance = <span class="hljs-number">0</span>,<br>    maxIdleTime = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (index &lt; queue.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-comment">// 广度优先搜索，移动 index 指针，提高性能</span><br>    distance++;<br>    <span class="hljs-keyword">const</span> length = queue.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; length) &#123;<br>      <span class="hljs-keyword">const</span> tmp = grah.<span class="hljs-title function_">get</span>(queue[index++]);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> tmp) &#123;<br>        <span class="hljs-keyword">if</span> (visited.<span class="hljs-title function_">has</span>(child)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 记录已访问过的节点，避免重复遍历</span><br>        visited.<span class="hljs-title function_">add</span>(child);<br>        <span class="hljs-keyword">const</span> idleTime = (((<span class="hljs-number">2</span> * distance - <span class="hljs-number">1</span>) / patience[child]) | <span class="hljs-number">0</span>) * patience[child] + <span class="hljs-number">2</span> * distance + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (idleTime &gt; maxIdleTime) maxIdleTime = idleTime; <span class="hljs-comment">// 计算空闲时间，更新最大值</span><br>        queue.<span class="hljs-title function_">push</span>(child);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxIdleTime;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1003. 检查替换后的词是否有效-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/06/03/subject/1003.%20%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/06/03/subject/1003.%20%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="检查替换后的词是否有效-MEDIUM"><a href="#检查替换后的词是否有效-MEDIUM" class="headerlink" title="检查替换后的词是否有效-MEDIUM"></a>检查替换后的词是否有效-MEDIUM</h1><p><a href="https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/">力扣题目</a></p><h1 id="方法一-匹配法"><a href="#方法一-匹配法" class="headerlink" title="方法一 匹配法"></a>方法一 匹配法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与 <a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号-EASY</a> 解题思路类似</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">while</span> (s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) != -<span class="hljs-number">1</span>) &#123;<br>    s = s.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/abc/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> !s.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">//</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2106. 摘水果-HARD</title>
    <link href="/xiaolanchong.githug.io/2023/05/14/subject/2106.%20%E6%91%98%E6%B0%B4%E6%9E%9C-HARD/"/>
    <url>/xiaolanchong.githug.io/2023/05/14/subject/2106.%20%E6%91%98%E6%B0%B4%E6%9E%9C-HARD/</url>
    
    <content type="html"><![CDATA[<h1 id="摘水果-HARD"><a href="#摘水果-HARD" class="headerlink" title="摘水果-HARD"></a>摘水果-HARD</h1><p><a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/">力扣题目</a></p><h1 id="方法一-二分查找"><a href="#方法一-二分查找" class="headerlink" title="方法一 二分查找"></a>方法一 二分查找</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxTotalFruits = <span class="hljs-keyword">function</span> (<span class="hljs-params">fruits, startPos, k</span>) &#123;<br>  <span class="hljs-keyword">const</span> n = fruits.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> indices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>  sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    sum[i + <span class="hljs-number">1</span>] = sum[i] + fruits[i][<span class="hljs-number">1</span>];<br>    indices[i] = fruits[i][<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(k / <span class="hljs-number">2</span>); x++) &#123;<br>    <span class="hljs-comment">//  先向左走 x 再向右走 k-x</span><br>    <span class="hljs-keyword">let</span> left = startPos - x;<br>    <span class="hljs-keyword">let</span> right = startPos + k - <span class="hljs-number">2</span> * x;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-title function_">lowerBound</span>(indices, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, left);<br>    <span class="hljs-keyword">let</span> end = <span class="hljs-title function_">upperBound</span>(indices, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, right);<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, sum[end] - sum[start]);<br>    <span class="hljs-comment">// 先向右走 x 再向左走 k - x</span><br>    left = startPos - (k - <span class="hljs-number">2</span> * x);<br>    right = startPos + x;<br>    start = <span class="hljs-title function_">lowerBound</span>(indices, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, left);<br>    end = <span class="hljs-title function_">upperBound</span>(indices, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, right);<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, sum[end] - sum[start]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">lowerBound</span> = (<span class="hljs-params">arr, left, right, val</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> res = right + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">const</span> mid = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (arr[mid] &gt;= val) &#123;<br>      res = mid;<br>      right = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">upperBound</span> = (<span class="hljs-params">arr, left, right, val</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> res = right + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">const</span> mid = left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (arr[mid] &gt; val) &#123;<br>      res = mid;<br>      right = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxTotalFruits</span>(paramFruits, paramStartPos, paramK));<br></code></pre></td></tr></table></figure><h1 id="方法二-模拟法"><a href="#方法二-模拟法" class="headerlink" title="方法二 模拟法"></a>方法二 模拟法</h1><blockquote><p>会超时</p></blockquote><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxTotalFruits = <span class="hljs-keyword">function</span> (<span class="hljs-params">fruits, startPos, k</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, val] <span class="hljs-keyword">of</span> fruits) &#123;<br>    map.<span class="hljs-title function_">set</span>(i, val);<br>  &#125;<br>  <span class="hljs-comment">//  右多</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(k / <span class="hljs-number">2</span>); i &lt;= <span class="hljs-number">0</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> left = startPos + i;<br>    <span class="hljs-keyword">let</span> right = startPos + k + i * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = left; j &lt;= right; j++) &#123;<br>      sum += map.<span class="hljs-title function_">get</span>(j) || <span class="hljs-number">0</span>;<br>    &#125;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, sum);<br>  &#125;<br>  <span class="hljs-comment">//  左多</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(k / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">let</span> right = startPos + i;<br>    <span class="hljs-keyword">let</span> left = startPos + k + i * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = left; j &lt;= right; j++) &#123;<br>      sum += map.<span class="hljs-title function_">get</span>(j) || <span class="hljs-number">0</span>;<br>    &#125;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, sum);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>970. 强整数-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/05/14/subject/970.%20%E5%BC%BA%E6%95%B4%E6%95%B0-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/05/14/subject/970.%20%E5%BC%BA%E6%95%B4%E6%95%B0-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="强整数-MEDIUM"><a href="#强整数-MEDIUM" class="headerlink" title="强整数-MEDIUM"></a>强整数-MEDIUM</h1><p><a href="https://leetcode.cn/problems/powerful-integers/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先确认幂的边界值</li><li>两数相加要小于等于 bound，由于最小值是 1，可以确定两只必须都小于 bound</li><li>可以确认 x 下所有值，y 下所有值</li><li>两数相加再判断满足条件的和 去重的带最终结果</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> powerfulIntegers = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y, bound</span>) &#123;<br>  <span class="hljs-keyword">let</span> tempX = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> numsX = [<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">let</span> tempY = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> numsY = [<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">while</span> (tempX &lt; bound) &#123;<br>      tempX *= x;<br>      numsX.<span class="hljs-title function_">push</span>(tempX);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (y != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">while</span> (tempY &lt; bound) &#123;<br>      tempY *= y;<br>      numsY.<span class="hljs-title function_">push</span>(tempY);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> tempArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numsX.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; numsY.<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">const</span> sum = numsX[i] + numsY[j];<br>      <span class="hljs-keyword">if</span> (sum &lt;= bound) &#123;<br>        tempArr.<span class="hljs-title function_">add</span>(sum);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [...tempArr];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1054. 距离相等的条形码-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/05/14/subject/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/05/14/subject/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="距离相等的条形码-MEDIUM"><a href="#距离相等的条形码-MEDIUM" class="headerlink" title="距离相等的条形码-MEDIUM"></a>距离相等的条形码-MEDIUM</h1><p><a href="https://leetcode.cn/problems/distant-barcodes/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>首先 barcodes 一定能生成满足条件的值，减少了我们判断边界值的情况</p></blockquote><ol><li>结果需要相邻不想同，那就是下标 +2 的设置</li><li>当某一个数大于总长度的一半是 他只能从 0 开始设置</li></ol><blockquote><p>结合上面的思路</p></blockquote><ol start="3"><li>生成 map 记录 val 和 count</li><li>创建两个指针 i&#x3D;0，j&#x3D;0; 当 count &lt;&#x3D; len&#x2F;2 时 从 j 开始设置，知道 j &lt;&#x3D; len</li><li>到 count &gt; len&#x2F;2，或 j &gt; len 时开始从 i 设置</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rearrangeBarcodes = <span class="hljs-keyword">function</span> (<span class="hljs-params">barcodes</span>) &#123;<br>  <span class="hljs-keyword">const</span> len = barcodes.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> barcodes;<br>  &#125;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> barcodes) &#123;<br>    map.<span class="hljs-title function_">set</span>(val, (map.<span class="hljs-title function_">get</span>(val) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [val, count] <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span> &amp;&amp; count &lt;= middle &amp;&amp; j &lt;= len) &#123;<br>      res[j] = val;<br>      count--;<br>      j += <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>      res[i] = val;<br>      count--;<br>      i += <span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写一个Promise</title>
    <link href="/xiaolanchong.githug.io/2023/05/14/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPromise/"/>
    <url>/xiaolanchong.githug.io/2023/05/14/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPromise/</url>
    
    <content type="html"><![CDATA[<h1 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h1><h2 id="首先看看我们-Promise-的通常用法"><a href="#首先看看我们-Promise-的通常用法" class="headerlink" title="首先看看我们 Promise 的通常用法"></a>首先看看我们 Promise 的通常用法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;返回成功结果&#x27;</span>, res);<br>&#125;);<br></code></pre></td></tr></table></figure><ol><li>需要一个 Promise 构造函数</li><li>需要传入一个执行方法，并且有 resolve、reject 两个方法</li><li>有 then 方法</li><li>当天需要满足 promise A+ 的规范 <a href="https://zhuanlan.zhihu.com/p/404659910">知乎答案</a></li></ol><blockquote><p>接下来我们开始自己手写一个 MpPromise</p></blockquote><h2 id="1-创建一个构造函数"><a href="#1-创建一个构造函数" class="headerlink" title="1. 创建一个构造函数"></a>1. 创建一个构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  result = <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = data;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = reason;<br>    &#125;;<br>    <span class="hljs-title function_">executor</span>(resolve, reject);<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一个 Promise 基本的结果就完成了</p></blockquote><blockquote><p>接下来我们给 Promise 添加状态 pending、fulfilled、rejected</p></blockquote><h2 id="pending、fulfilled、rejected"><a href="#pending、fulfilled、rejected" class="headerlink" title="pending、fulfilled、rejected"></a>pending、fulfilled、rejected</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  state = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  result = <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> != <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = data;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> != <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = reason;<br>    &#125;;<br>    <span class="hljs-title function_">executor</span>(resolve, reject);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>看着好像没啥问题了，但 state,result 好像不怎么安全，所以我们需要把他们写成私有属性</p></blockquote><blockquote><p>pending、fulfilled、rejected 字符串的直接使用，给后期的维护也留下了隐患</p></blockquote><blockquote><p>resolve、reject 方法内的代码有点相似，那我们可以考虑抽离代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-comment">// #开头表示私有属性</span><br>  #<span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  #<span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  #<span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  #state = <span class="hljs-variable language_">this</span>.<span class="hljs-property">PENDING</span>;<br>  #result = <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>      <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeState</span>(<span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">FULFILLED</span>, data);<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeState</span>(<span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">REJECTED</span>, reason);<br>    &#125;;<br>    <span class="hljs-title function_">executor</span>(resolve, reject);<br>  &#125;<br>  #<span class="hljs-title function_">changeState</span>(<span class="hljs-params">state, reject</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> != <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = result;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接下来我们来完善-then-方法"><a href="#接下来我们来完善-then-方法" class="headerlink" title="接下来我们来完善 then 方法"></a>接下来我们来完善 then 方法</h2><blockquote><p>then 是可以链式调用的所以返回也是个 Promise</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  ...<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#state === <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.#result)<br>        <span class="hljs-title function_">resolve</span>(data);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">const</span> reason = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.#result)<br>        <span class="hljs-title function_">reject</span>(reason);<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>  &#125;,<span class="hljs-number">1000</span>)<br>&#125;)<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>如果是异步的我们会发现 then 拿不到结果，那么何时才能拿到结果呢</p></blockquote><blockquote><p>次数我们可以回想到之前的 #changeState 方法</p></blockquote><blockquote><p>那么如何才能让 #changeState 来支持 then 里的回调呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  #handlers = []; <span class="hljs-comment">//为什么是数组呢 因为可能存在多个then</span><br>  ...<br>  #<span class="hljs-title function_">changeState</span>(<span class="hljs-params">state, reject</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> != <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = result;<br>    <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">run</span>();<br>  &#125;<br>  #<span class="hljs-title function_">runOne</span>(<span class="hljs-params">callblck, resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">callblck</span>(<span class="hljs-variable language_">this</span>.#result);<br>    <span class="hljs-title function_">resolve</span>(data);<br>  &#125;<br>  #<span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#state === <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.#handlers.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = <span class="hljs-variable language_">this</span>.#handlers.<span class="hljs-title function_">shift</span>();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#state === <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">runOne</span>(onFulfilled, resolve, reject);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">runOne</span>(onRejected, resolve, reject);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.#handlers.<span class="hljs-title function_">push</span>(&#123;<br>        onFulfilled,<br>        onRejected,<br>        resolve,<br>        reject<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">run</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>接下来我们需要分析 #runOne 了, callback 存在几种情况呢</p></blockquote><ol><li>不是个函数</li><li>放回的结果是 promise</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  #<span class="hljs-title function_">isPromiseLike</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 注意不是单纯的判断构造函数 满足promise A+规范的都属于promise</span><br>    <span class="hljs-keyword">if</span> ((value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span>) || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  #<span class="hljs-title function_">runOne</span>(<span class="hljs-params">callblck, resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">const</span> settled = <span class="hljs-variable language_">this</span>.#state == <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">FULFILLED</span> ? resolve : reject;<br>      <span class="hljs-title function_">settled</span>(<span class="hljs-variable language_">this</span>.#result);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.#result);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">isPromiseLike</span>(data)) &#123;<br>      data.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写到这里 myPromise 基本可用了,但还有一些细节要处理</p></blockquote><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-comment">// #开头表示私有属性</span><br><br>  <span class="hljs-comment">// 状态常量</span><br>  #<span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  #<span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>  #<span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br><br>  <span class="hljs-comment">// 状态</span><br>  #state = <span class="hljs-variable language_">this</span>.<span class="hljs-property">PENDING</span>;<br>  <span class="hljs-comment">// 结果</span><br>  #result = <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-comment">// then 堆栈</span><br>  #handlers = [];<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>      <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeState</span>(<span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">FULFILLED</span>, data);<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeState</span>(<span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">REJECTED</span>, reason);<br>    &#125;;<br>    <span class="hljs-comment">// 捕获错误 但无法捕获异步错误</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">reject</span>(err);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 只会有一个最终状态</span><br>  #<span class="hljs-title function_">changeState</span>(<span class="hljs-params">state, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#state !== <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.#state = state;<br>    <span class="hljs-variable language_">this</span>.#result = result;<br>    <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">run</span>();<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 判断是不是promise</span><br><span class="hljs-comment">   * 满足promise A+规范</span><br><span class="hljs-comment">   */</span><br>  #<span class="hljs-title function_">isPromiseLike</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span>) || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 微队列</span><br>  #<span class="hljs-title function_">runMicroTask</span>(<span class="hljs-params">func</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> process.<span class="hljs-property">nextTick</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">//   node 环境</span><br>      process.<span class="hljs-title function_">nextTick</span>(func);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 浏览器环境 监听</span><br>      <span class="hljs-keyword">const</span> ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(func);<br>      <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>      ob.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>        <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>      &#125;);<br>      textNode.<span class="hljs-property">data</span> = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(func, <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>  #<span class="hljs-title function_">runOne</span>(<span class="hljs-params">callback, resolve, reject</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">runMicroTask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 不是个函数时直接透传结果</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> settled = <span class="hljs-variable language_">this</span>.#state == <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">FULFILLED</span> ? resolve : reject;<br>        <span class="hljs-title function_">settled</span>(<span class="hljs-variable language_">this</span>.#result);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.#result);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">isPromiseLike</span>(data)) &#123;<br>          data.<span class="hljs-title function_">then</span>(resolve, reject);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(data);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  #<span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#state === <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.#handlers.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = <span class="hljs-variable language_">this</span>.#handlers.<span class="hljs-title function_">shift</span>();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#state === <span class="hljs-variable language_">this</span>.#<span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">runOne</span>(onFulfilled, resolve, reject);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">runOne</span>(onRejected, resolve, reject);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.#handlers.<span class="hljs-title function_">push</span>(&#123;<br>        onFulfilled,<br>        onRejected,<br>        resolve,<br>        reject<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">run</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runMicroTask-方法"><a href="#runMicroTask-方法" class="headerlink" title="#runMicroTask 方法"></a>#runMicroTask 方法</h2><blockquote><p>熟悉事件循环的朋友应该不陌生 <a href="/xiaolanchong.githug.io/2023/04/09/interview/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" title="事件循环">事件循环</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  ...<br>  #<span class="hljs-title function_">runMicroTask</span>(<span class="hljs-params">func</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> process.<span class="hljs-property">nextTick</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">//   node 环境</span><br>      process.<span class="hljs-title function_">nextTick</span>(func);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 浏览器环境 监听</span><br>      <span class="hljs-keyword">const</span> ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(func);<br>      <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>      ob.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>        <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>      &#125;);<br>      textNode.<span class="hljs-property">data</span> = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(func, <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1376. 通知所有员工所需的时间-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/05/13/subject/1376.%20%E9%80%9A%E7%9F%A5%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/05/13/subject/1376.%20%E9%80%9A%E7%9F%A5%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="1376-通知所有员工所需的时间"><a href="#1376-通知所有员工所需的时间" class="headerlink" title="1376. 通知所有员工所需的时间"></a>1376. 通知所有员工所需的时间</h1><p><a href="https://leetcode.cn/problems/time-needed-to-inform-all-employees/">力扣题目</a></p><h1 id="方法一-DFS-深度优先算法"><a href="#方法一-DFS-深度优先算法" class="headerlink" title="方法一 DFS 深度优先算法"></a>方法一 DFS 深度优先算法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numOfMinutes = <span class="hljs-keyword">function</span> (<span class="hljs-params">n, headID, manager, informTime</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-comment">// 初始化哈希表 下级关系</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">const</span> _manager = manager[i];<br>    <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(_manager)) &#123;<br>      map.<span class="hljs-title function_">set</span>(_manager, []);<br>    &#125;<br>    map.<span class="hljs-title function_">get</span>(_manager).<span class="hljs-title function_">push</span>(i);<br>  &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dfs</span> = (<span class="hljs-params">headID, informTime, map</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> subordinate = map.<span class="hljs-title function_">get</span>(headID) || [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> user <span class="hljs-keyword">of</span> subordinate) &#123;<br>      res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title function_">dfs</span>(user, informTime, map));<br>    &#125;<br>    <span class="hljs-keyword">return</span> informTime[headID] + res;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">dfs</span>(headID, informTime, map);<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numOfMinutes</span>(paramN, paramHeadID, paramManager, paramInformTime));<br></code></pre></td></tr></table></figure><h1 id="方法二-BFS-广度优先算法"><a href="#方法二-BFS-广度优先算法" class="headerlink" title="方法二 BFS 广度优先算法"></a>方法二 BFS 广度优先算法</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numOfMinutes = <span class="hljs-keyword">function</span> (<span class="hljs-params">n, headID, manager, informTime</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-comment">// 初始化哈希表 下级关系</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">const</span> _manager = manager[i];<br>    <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(_manager)) &#123;<br>      map.<span class="hljs-title function_">set</span>(_manager, []);<br>    &#125;<br>    map.<span class="hljs-title function_">get</span>(_manager).<span class="hljs-title function_">push</span>(i);<br>  &#125;<br>  <span class="hljs-comment">// 初始化队列 [[用户, 时间]]</span><br>  <span class="hljs-keyword">const</span> queue = [[headID, <span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> [user, time] = queue.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-comment">// 但没有下属时 更新结果</span><br>    <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(user)) &#123;<br>      res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, time);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 把每个下属更新到列表</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">get</span>(user)) &#123;<br>        queue.<span class="hljs-title function_">push</span>([key, time + informTime[user]]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numOfMinutes</span>(paramN, paramHeadID, paramManager, paramInformTime));<br></code></pre></td></tr></table></figure><h1 id="方法三-记忆化搜索"><a href="#方法三-记忆化搜索" class="headerlink" title="方法三 记忆化搜索"></a>方法三 记忆化搜索</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numOfMinutes = <span class="hljs-keyword">function</span> (<span class="hljs-params">n, headID, manager, informTime</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dfs</span> = (<span class="hljs-params">cur</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (cur == headID) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(cur)) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">dfs</span>(manager[cur]) + informTime[manager[cur]];<br>      map.<span class="hljs-title function_">set</span>(cur, res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(cur);<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title function_">dfs</span>(i));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numOfMinutes</span>(paramN, paramHeadID, paramManager, paramInformTime));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2441. 与对应负数同时存在的最大正整数-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/05/13/subject/2441.%20%E4%B8%8E%E5%AF%B9%E5%BA%94%E8%B4%9F%E6%95%B0%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%95%B4%E6%95%B0-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/05/13/subject/2441.%20%E4%B8%8E%E5%AF%B9%E5%BA%94%E8%B4%9F%E6%95%B0%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%95%B4%E6%95%B0-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="与对应负数同时存在的最大正整数-EASY"><a href="#与对应负数同时存在的最大正整数-EASY" class="headerlink" title="与对应负数同时存在的最大正整数-EASY"></a>与对应负数同时存在的最大正整数-EASY</h1><p><a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">力扣题目</a></p><h1 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一 暴力法"></a>方法一 暴力法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMaxK = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = -<span class="hljs-number">1</span>;<br>  nums.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 由于nums是非零的数组 所以可以使用find查询</span><br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x == -item)) &#123;<br>      res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, item);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findMaxK</span>(paramNums));<br></code></pre></td></tr></table></figure><h1 id="方法二-哈希法"><a href="#方法二-哈希法" class="headerlink" title="方法二 哈希法"></a>方法二 哈希法</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMaxK = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">let</span> res = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    map.<span class="hljs-title function_">set</span>(num, <span class="hljs-literal">true</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(-num)) &#123;<br>      res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, num);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findMaxK</span>(paramNums));<br></code></pre></td></tr></table></figure><h1 id="方法三-排序-双指针"><a href="#方法三-排序-双指针" class="headerlink" title="方法三 排序+双指针"></a>方法三 排序+双指针</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMaxK = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  nums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 排序 从小到大</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nums);<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-keyword">if</span> (-nums[left] &lt; nums[right]) &#123;<br>      right--;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (-nums[left] &gt; nums[right]) &#123;<br>      left++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> nums[right];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findMaxK</span>(paramNums));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1048. 最长字符串链-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/05/13/subject/1048.%20%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/05/13/subject/1048.%20%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="最长字符串链-MEDIUM"><a href="#最长字符串链-MEDIUM" class="headerlink" title="最长字符串链-MEDIUM"></a>最长字符串链-MEDIUM</h1><p><a href="https://leetcode.cn/problems/longest-string-chain/">力扣题目</a></p><h1 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先理解规则，abc &gt; [a, ab, abc];ab &gt; [a, ab] 可以看出如果我们想知道满足 abc 的数量我们可以先去查找满足 ab 的数量</li><li>创建以个 map 用来存储 a、ab、abc 分别对应的满足长度</li><li>从中判断最大值就是输出的结果</li><li>由于前身的字符串长度一定更短，所以我们可以从较短的数据线开始处理</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestStrChain = <span class="hljs-keyword">function</span> (<span class="hljs-params">words</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  words = words.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">length</span> - b.<span class="hljs-property">length</span>); <span class="hljs-comment">//排序</span><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//最终输出的结果</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    map.<span class="hljs-title function_">set</span>(word, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> prev = word.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i) + word.<span class="hljs-title function_">substring</span>(i, i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(prev)) &#123;<br>        map.<span class="hljs-title function_">set</span>(word, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(map.<span class="hljs-title function_">get</span>(word), map.<span class="hljs-title function_">get</span>(prev) + <span class="hljs-number">1</span>));<br>      &#125;<br>    &#125;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, map.<span class="hljs-title function_">get</span>(word));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1027. 最长等差数列-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/1027.%20%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/1027.%20%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="最长等差数列-MEDIUM"><a href="#最长等差数列-MEDIUM" class="headerlink" title="最长等差数列-MEDIUM"></a>最长等差数列-MEDIUM</h1><p><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/">力扣题目</a></p><h1 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先获得最大值和最小值计 计算出最大等差数值 diff</li><li>注意数组不是有序数组 所以等差数范围是 [-diff,diff]</li><li>遍历得到 每个数传入 + diff</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestArithSeqLength = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...nums);<br>  <span class="hljs-keyword">const</span> min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...nums);<br>  <span class="hljs-keyword">const</span> diff = max - min;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> d = -diff; d &lt;= diff; d++) &#123;<br>    <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(max + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>      <span class="hljs-keyword">const</span> prev = num + d;<br>      <span class="hljs-keyword">if</span> (prev &gt;= min &amp;&amp; prev &lt;= max &amp;&amp; temp[prev] !== -<span class="hljs-number">1</span>) &#123;<br>        temp[num] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(temp[num], temp[prev] + <span class="hljs-number">1</span>);<br>        res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(temp[num], res);<br>      &#125;<br>      temp[num] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(temp[num], <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1157. 子数组中占绝大多数的元素-HARD</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/1157.%20%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8D%A0%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0-HARD/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/1157.%20%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8D%A0%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0-HARD/</url>
    
    <content type="html"><![CDATA[<h1 id="子数组中占绝大多数的元素-HARD"><a href="#子数组中占绝大多数的元素-HARD" class="headerlink" title="子数组中占绝大多数的元素-HARD"></a>子数组中占绝大多数的元素-HARD</h1><p><a href="https://leetcode.cn/problems/online-majority-element-in-subarray/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>保存一个存有 每个数字 所谓位置的集合</li><li>得到集合后就可以轻易的判断出一个数在区间是否存在满足次数</li><li>但是由于耗时的问题无法实现全部的遍历</li></ol><blockquote><p>官方给出的方式是随机抽样</p></blockquote><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先生成一个对应位置的正序列表</span><br><span class="hljs-comment"> * [0,0,1,1]</span><br><span class="hljs-comment"> * new Map([</span><br><span class="hljs-comment"> *    [0,[0,1]]</span><br><span class="hljs-comment"> *    [1,[2,3]]</span><br><span class="hljs-comment"> * ])</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">MajorityChecker</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">has</span>(arr[i])) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">set</span>(arr[i], []);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">get</span>(arr[i]).<span class="hljs-title function_">push</span>(i);<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span> = arr;<br>&#125;;<br><span class="hljs-comment">// 随机取样</span><br><span class="hljs-title class_">MajorityChecker</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">query</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">left, right, threshold</span>) &#123;<br>  <span class="hljs-keyword">const</span> length = right - left + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * length) + left;<br>    <span class="hljs-keyword">const</span> num = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[index];<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">get</span>(num);<br>    <span class="hljs-keyword">const</span> start = <span class="hljs-title function_">binarySearch</span>(arr, left);<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-title function_">binarySearch</span>(arr, right + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (end - start &gt;= threshold) &#123;<br>      <span class="hljs-keyword">return</span> num;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-comment">// 双指针法 寻找target后的最近位置</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) &#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (arr[mid] &gt;= target) &#123;<br>      right = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1053. 交换一次的先前排列-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/1053.%20%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/1053.%20%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="交换一次的先前排列-MEDIUM"><a href="#交换一次的先前排列-MEDIUM" class="headerlink" title="交换一次的先前排列-MEDIUM"></a>交换一次的先前排列-MEDIUM</h1><p><a href="https://leetcode.cn/problems/previous-permutation-with-one-swap/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>小于原数组的最大排序 所以在 length-1 到 0 选择 i 的位置</li><li>判断思路 i &gt; i+1 得到 i 的位置</li><li>在 length-1 到 i 中寻找 j 的位置</li><li>判断思路 j &lt; i 得到 j 的位置</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prevPermOpt</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> n = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">let</span> j = n - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (arr[j] &gt;= arr[i] || arr[j] == arr[j - <span class="hljs-number">1</span>]) &#123;<br>        j--;<br>      &#125;<br>      <span class="hljs-keyword">let</span> temp = arr[j];<br>      arr[j] = arr[i];<br>      arr[i] = temp;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1041. 困于环中的机器人-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/1041.%20%E5%9B%B0%E4%BA%8E%E7%8E%AF%E4%B8%AD%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/1041.%20%E5%9B%B0%E4%BA%8E%E7%8E%AF%E4%B8%AD%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="困于环中的机器人-MEDIUM"><a href="#困于环中的机器人-MEDIUM" class="headerlink" title="困于环中的机器人-MEDIUM"></a>困于环中的机器人-MEDIUM</h1><p><a href="https://leetcode.cn/problems/robot-bounded-in-circle/">力扣题目</a></p><h1 id="方法一-模拟法"><a href="#方法一-模拟法" class="headerlink" title="方法一 模拟法"></a>方法一 模拟法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>指令 G、L、R</li><li>方向 E(1,0)、S(0,-1)、W(-1,0)、N(0,1)</li><li>当机器人回到 (0,0) 无论机器人面朝那个返现都能回到原点</li><li>当机器坐标不在 (0,0) 上且反向还是朝 北 的话，那么机器人用于也会不到原点</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isRobotBounded = <span class="hljs-keyword">function</span> (<span class="hljs-params">instructions</span>) &#123;<br>  <span class="hljs-keyword">let</span> [x, y] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> arrowArr = [<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>];<br>  <span class="hljs-keyword">let</span> current = <span class="hljs-number">3</span>; <span class="hljs-comment">// E S W N</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">arrowFn</span>(<span class="hljs-params">arrow</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (arrow) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>        x += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>        y -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>        x -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;N&#x27;</span>:<br>        y += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> arr = instructions.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> action = arr[i];<br>    <span class="hljs-keyword">switch</span> (action) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;G&#x27;</span>:<br>        <span class="hljs-title function_">arrowFn</span>(arrowArr[current]);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>        current = (current + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>        current = (current + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> current != <span class="hljs-number">3</span> || (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1019. 链表中的下一个更大节点-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/1019.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/1019.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="链表中的下一个更大节点-MEDIUM"><a href="#链表中的下一个更大节点-MEDIUM" class="headerlink" title="链表中的下一个更大节点-MEDIUM"></a>链表中的下一个更大节点-MEDIUM</h1><p><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/">力扣题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单链表的定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法一-递归法"><a href="#方法一-递归法" class="headerlink" title="方法一 递归法"></a>方法一 递归法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> nextLargerNodes = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>  <span class="hljs-keyword">let</span> answer = [];<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">links</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!links) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> other = links;<br>    <span class="hljs-keyword">while</span> (other.<span class="hljs-property">next</span> &amp;&amp; links.<span class="hljs-property">val</span> &gt;= other.<span class="hljs-property">next</span>.<span class="hljs-property">val</span>) &#123;<br>      other = other.<span class="hljs-property">next</span>;<br>    &#125;<br>    answer.<span class="hljs-title function_">push</span>(other.<span class="hljs-property">next</span>?.<span class="hljs-property">val</span> &gt; links.<span class="hljs-property">val</span> ? other.<span class="hljs-property">next</span>?.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>);<br>    <span class="hljs-title function_">fn</span>(links.<span class="hljs-property">next</span>);<br>  &#125;;<br>  <span class="hljs-title function_">fn</span>(head);<br>  <span class="hljs-keyword">return</span> answer;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-单调栈"><a href="#方法二-单调栈" class="headerlink" title="方法二 单调栈"></a>方法二 单调栈</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>用一个栈储存已经遍历过的，且没有找到下一个更大节点的值的节点，如果有的，推出栈，那么栈里面的元素肯定是递减的</li><li>遍历链表，从栈顶开始，如果栈顶的元素值比当前链表节点的值小，脱出栈顶，将栈顶所在位置的结果值设置为当前节点的值，否则，将该节点值以及该位置推入链表</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> nextLargerNodes = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>  <span class="hljs-keyword">let</span> answer = [];<br>  <span class="hljs-keyword">let</span> stack = [];<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    answer[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> &#123; val, next &#125; = head;<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; val) &#123;<br>      answer[stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]] = val;<br>      stack.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>    <span class="hljs-comment">// 记录当前值和下表</span><br>    stack.<span class="hljs-title function_">push</span>([i, val]);<br>    i++;<br>    head = next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> answer;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1017. 负二进制转换-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/1017.%20%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/1017.%20%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="负二进制转换-MEDIUM"><a href="#负二进制转换-MEDIUM" class="headerlink" title="负二进制转换-MEDIUM"></a>负二进制转换-MEDIUM</h1><p><a href="https://leetcode.cn/problems/convert-to-base-2/">力扣题目</a></p><h1 id="方法一-模拟进位"><a href="#方法一-模拟进位" class="headerlink" title="方法一 模拟进位"></a>方法一 模拟进位</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>i 为偶数 2 的 i 次方 &#x3D;&#x3D; -2 的 i 次方</li><li>i 为奇数 2 的 i 次方 &#x3D;&#x3D; -2 的(i+1)次方 + -2 的 i 次方</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baseNeg2</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> bins = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">32</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span> &amp;&amp; n !== <span class="hljs-number">0</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) !== <span class="hljs-number">0</span>) &#123;<br>      bins[i]++;<br>      <span class="hljs-comment">// i为奇数 需要加上 i+1</span><br>      <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) !== <span class="hljs-number">0</span>) &#123;<br>        bins[i + <span class="hljs-number">1</span>]++;<br>      &#125;<br>    &#125;<br>    n &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 转换为-2进制</span><br>  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> val = carry + bins[i];<br>    bins[i] = val &amp; <span class="hljs-number">1</span>;<br>    carry = (val - bins[i]) / -<span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-comment">// 生成结构</span><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = bins.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span> (bins[i] || res) &#123;<br>      res += bins[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 字符串转换整数 (atoi)-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串转换整数-atoi-MEDIUM"><a href="#字符串转换整数-atoi-MEDIUM" class="headerlink" title="字符串转换整数 (atoi)-MEDIUM"></a>字符串转换整数 (atoi)-MEDIUM</h1><p><a href="https://leetcode.cn/problems/string-to-integer-atoi/">力扣题目</a></p><h1 id="方法一-利用-parseInt"><a href="#方法一-利用-parseInt" class="headerlink" title="方法一 利用 parseInt"></a>方法一 利用 parseInt</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myAtoi = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">const</span> max = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> min = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">parseInt</span>(s, <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">if</span> (res &gt; max) &#123;<br>    <span class="hljs-keyword">return</span> max;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &lt; min) &#123;<br>    <span class="hljs-keyword">return</span> min;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> res ? res : <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-官方-自动机-思路"><a href="#方法二-官方-自动机-思路" class="headerlink" title="方法二 官方 自动机 思路"></a>方法二 官方 自动机 思路</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automaton</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;start&#x27;</span>;<br>    <span class="hljs-comment">// 执行阶段，默认处于开始执行阶段</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;start&#x27;</span>;<br>    <span class="hljs-comment">// 正负符号，默认是正数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sign</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 数值，默认是0</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      关键点：</span><br><span class="hljs-comment">      状态和执行阶段的对应表</span><br><span class="hljs-comment">      含义如下：</span><br><span class="hljs-comment">      [执行阶段, [空格, 正负, 数值, 其他]]</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>      [<span class="hljs-string">&#x27;start&#x27;</span>, [<span class="hljs-string">&#x27;start&#x27;</span>, <span class="hljs-string">&#x27;signed&#x27;</span>, <span class="hljs-string">&#x27;in_number&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>]],<br>      [<span class="hljs-string">&#x27;signed&#x27;</span>, [<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;in_number&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>]],<br>      [<span class="hljs-string">&#x27;in_number&#x27;</span>, [<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;in_number&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>]],<br>      [<span class="hljs-string">&#x27;end&#x27;</span>, [<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>]]<br>    ]);<br>  &#125;<br>  <span class="hljs-comment">// 获取状态的索引</span><br>  <span class="hljs-title function_">getIndex</span>(<span class="hljs-params">char</span>) &#123;<br>    <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>      <span class="hljs-comment">// 空格判断</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27;-&#x27;</span> || char === <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 正负判断</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Number</span>(char) === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(char)) &#123;<br>      <span class="hljs-comment">// 数值判断</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 其他情况</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    关键点：</span><br><span class="hljs-comment">    字符转换执行函数</span><br><span class="hljs-comment">    */</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">char</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>)[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getIndex</span>(char)];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;in_number&#x27;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> * <span class="hljs-number">10</span> + (char - <span class="hljs-number">0</span>);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> =<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sign</span> === <span class="hljs-number">1</span><br>          ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span>)<br>          : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span>, -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(-<span class="hljs-number">2</span>, <span class="hljs-number">31</span>));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;signed&#x27;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">sign</span> = char === <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> myAtoi = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">let</span> automaton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Automaton</span>();<br>  <span class="hljs-comment">// 遍历每个字符</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> str) &#123;<br>    <span class="hljs-comment">// 依次进行转换</span><br>    automaton.<span class="hljs-title function_">get</span>(char);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回值，整数 = 正负 * 数值</span><br>  <span class="hljs-keyword">return</span> automaton.<span class="hljs-property">sign</span> * automaton.<span class="hljs-property">answer</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 整数反转-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/7.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/7.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="整数反转-MEDIUM"><a href="#整数反转-MEDIUM" class="headerlink" title="整数反转-MEDIUM"></a>整数反转-MEDIUM</h1><p><a href="https://leetcode.cn/problems/reverse-integer/">力扣题目</a></p><h1 id="方法一-模拟法"><a href="#方法一-模拟法" class="headerlink" title="方法一 模拟法"></a>方法一 模拟法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reverse = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> max = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> min = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x) &gt;= <span class="hljs-number">1</span>) &#123;<br>    res = res * <span class="hljs-number">10</span> + (x % <span class="hljs-number">10</span>);<br>    x = <span class="hljs-built_in">parseInt</span>(x / <span class="hljs-number">10</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res &gt;= min &amp;&amp; res &lt;= max ? res : <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. N字形变换-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/6.%20N%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/6.%20N%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="N-字形变换-MEDIUM"><a href="#N-字形变换-MEDIUM" class="headerlink" title="N 字形变换-MEDIUM"></a>N 字形变换-MEDIUM</h1><p><a href="https://leetcode.cn/problems/zigzag-conversion/">力扣题目</a></p><ol><li>N 字形 周期为 t &#x3D; r * 2 - 2</li><li>除了 0 与 r - 1 的位置其他位置都只有一个点</li></ol><h1 id="方法一-矩阵法"><a href="#方法一-矩阵法" class="headerlink" title="方法一 矩阵法"></a>方法一 矩阵法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>模拟矩阵法</li><li>结合规律 我们可以通过 x 指针模拟 N 字变化的顺序 0 -&gt; r -1 &gt; 0</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> convert = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, numRows</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">let</span> len = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> r = numRows;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span> || len &lt; r) &#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(r).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> []);<br>  <span class="hljs-keyword">const</span> t = r * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">//周期</span><br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    temp[x].<span class="hljs-title function_">push</span>(s[i]);<br>    <span class="hljs-keyword">if</span> (i % t &lt; r - <span class="hljs-number">1</span>) &#123;<br>      x++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      x--;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row <span class="hljs-keyword">of</span> temp) &#123;<br>    res += row.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法一-直接构造"><a href="#方法一-直接构造" class="headerlink" title="方法一 直接构造"></a>方法一 直接构造</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>通过规律直接构建</li><li>通过规律 我们可以一次性知道 0 位置的所有值</li><li>依次类推得到完整的数值</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> convert = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, numRows</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> r = numRows;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span> || len &lt; r) &#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">const</span> t = r * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">//周期</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len - i; j += t) &#123;<br>      res += s[i + j];<br>      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt; r - <span class="hljs-number">1</span> &amp;&amp; j + t - i &lt; len) &#123;<br>        res += s[j + t - i];<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 寻找两个正序数组的中位数-HARD</title>
    <link href="/xiaolanchong.githug.io/2023/04/22/subject/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-HARD/"/>
    <url>/xiaolanchong.githug.io/2023/04/22/subject/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-HARD/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找两个正序数组的中位数-HARD"><a href="#寻找两个正序数组的中位数-HARD" class="headerlink" title="寻找两个正序数组的中位数-HARD"></a>寻找两个正序数组的中位数-HARD</h1><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">力扣题目</a></p><h1 id="方法一-函数合并-取中法"><a href="#方法一-函数合并-取中法" class="headerlink" title="方法一 函数合并 取中法"></a>方法一 函数合并 取中法</h1><blockquote><p>时间复杂度 O((m+n)log(m+n)) 空间复杂度 O(m+n)</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先合并两个有序数组并排序</li><li>然后找到中位数</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) &#123;<br>  <span class="hljs-keyword">const</span> newNums = [...nums1, ...nums2].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> len = newNums.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// if (len % 2 == 0) &#123;</span><br>  <span class="hljs-comment">//   return (newNums[(len - 2) / 2] + newNums[len / 2]) / 2;</span><br>  <span class="hljs-comment">// &#125; else &#123;</span><br>  <span class="hljs-comment">//   return newNums[(len - 1) / 2];</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// 上述可以优化成</span><br>  <span class="hljs-keyword">return</span> (<br>    (newNums[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len / <span class="hljs-number">2</span>)] + newNums[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)]) / <span class="hljs-number">2</span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-双指针合并数组-取中法"><a href="#方法二-双指针合并数组-取中法" class="headerlink" title="方法二 双指针合并数组 取中法"></a>方法二 双指针合并数组 取中法</h1><blockquote><p>时间复杂度 O(m+n) 空间复杂度 O(m+n)</p></blockquote><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先合并两个有序数组并排序</li><li>然后找到中位数</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) &#123;<br>  <span class="hljs-keyword">let</span> len1 = nums1.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> len2 = nums2.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> newNums = [];<br>  <span class="hljs-keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;<br>    <span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;<br>      newNums.<span class="hljs-title function_">push</span>(nums1[i]);<br>      i++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      newNums.<span class="hljs-title function_">push</span>(nums2[j]);<br>      j++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (i &lt; len1) &#123;<br>    newNums.<span class="hljs-title function_">push</span>(nums1[i]);<br>    i++;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (j &lt; len2) &#123;<br>    newNums.<span class="hljs-title function_">push</span>(nums2[j]);<br>    j++;<br>  &#125;<br>  <span class="hljs-comment">// 以上是合并排序</span><br><br>  <span class="hljs-keyword">const</span> len = newNums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">return</span> (<br>    (newNums[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len / <span class="hljs-number">2</span>)] + newNums[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)]) / <span class="hljs-number">2</span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法三-二分查找-（寻找第-K-小数）"><a href="#方法三-二分查找-（寻找第-K-小数）" class="headerlink" title="方法三 二分查找 （寻找第 K 小数）"></a>方法三 二分查找 （寻找第 K 小数）</h1><blockquote><p>时间复杂时要求 O(log(m+n))</p></blockquote><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>先确认中位数的位置 k</p><ul><li>奇数情况一个中位数：k &#x3D;(m+n+1)&#x2F;2</li><li>偶数情况两个中位数：k1 &#x3D;(m+n)&#x2F;2 k2&#x3D;(m+n+2)&#x2F;2</li><li>也可以合并上述两种情况 假设 k1 &#x3D; Math.floor((m+n+1)&#x2F;2); k2 &#x3D; Math.floor((m+n+2)&#x2F;2)</li></ul></li><li><p>p &#x3D; Math.floor(k&#x2F;2);</p><ul><li>比较 arr1[p-1] arr2[p-1], 假设前者小</li><li>由于数组都是正序的，所以可以排除 [s,p-1] 范围不可能是第 k 小的数，可以排除 剩下[p,arr1.length-1]</li><li>剩下数组中找 k 小的数， k &#x3D; k - (p-1 - s +1) &#x3D; k- (p - s);</li><li>重复操作 知道 k&#x3D;&#x3D;1 比较两个数数组中第一个数字大小，取小的就是结果</li></ul></li><li><p>需要考虑</p><ul><li>其中一个数组小于 p 直接去取最后一位</li><li>其中一个数组长度等于 0，从第二个数组中取第 k 小的数</li><li>arr1[p-1]&#x3D;&#x3D;arr2[p-1],随便删除那一段</li></ul></li></ol><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) &#123;<br>  <span class="hljs-keyword">let</span> m = nums1.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> n = nums2.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">let</span> k = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">findKVal</span>(nums1, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> k1 = (m + n) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> k2 = (m + n) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">findKVal</span>(nums1, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k1);<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">findKVal</span>(nums1, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k2);<br>    <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-comment">// 上述可以合并成下面写法</span><br>  <span class="hljs-comment">// let i = Math.floor((m + n + 1) / 2);</span><br>  <span class="hljs-comment">// let j = Math.floor((m + n + 2) / 2);</span><br>  <span class="hljs-comment">// const left = findKVal(nums1, 0, m - 1, nums2, 0, n - 1, i);</span><br>  <span class="hljs-comment">// const right = findKVal(nums1, 0, m - 1, nums2, 0, n - 1, j);</span><br>  <span class="hljs-comment">// return (left + right) / 2;</span><br>&#125;;<br><span class="hljs-keyword">var</span> findKVal = <span class="hljs-keyword">function</span> (<span class="hljs-params">arr1, s1, e1, arr2, s2, e2, k</span>) &#123;<br>  <span class="hljs-keyword">let</span> l1 = e1 - s1 + <span class="hljs-number">1</span>; <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">let</span> l2 = e2 - s2 + <span class="hljs-number">1</span>; <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 让 n 始终大于等 n 减少后面的边界判断</span><br>  <span class="hljs-keyword">if</span> (l1 &gt; l2) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">findKVal</span>(arr2, s2, e2, arr1, s1, e1, k);<br>  &#125;<br>  <span class="hljs-comment">// 当一个数组等于0了 直接在另一个数组中取第k小的数</span><br>  <span class="hljs-keyword">if</span> (l1 == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr2[s2 + k - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-comment">// 当 k ==1 说明查询结束 比较两数组第一个数小的就是k小的数</span><br>  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(arr1[s1], arr2[s2]);<br>  &#125;<br>  <span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(k / <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 需要考虑数组长度小于 p 的情况</span><br>  <span class="hljs-keyword">let</span> i = s1 + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(l1, p) - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> j = s2 + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(l2, p) - <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 递归逻辑</span><br>  <span class="hljs-keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">findKVal</span>(arr1, i + <span class="hljs-number">1</span>, e1, arr2, s2, e2, k - (i - s1 + <span class="hljs-number">1</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">findKVal</span>(arr1, s1, e1, arr2, j + <span class="hljs-number">1</span>, e2, k - (j - s2 + <span class="hljs-number">1</span>));<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>58. 最后一个单词的长度-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="最后一个单词的长度-EASY"><a href="#最后一个单词的长度-EASY" class="headerlink" title="最后一个单词的长度-EASY"></a>最后一个单词的长度-EASY</h1><p><a href="https://leetcode.cn/problems/length-of-last-word/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>因为查找的是最后一个单词，所以我们从后向前遍历</li><li>首先寻找到 结束位置</li><li>然后在结束位置再次遍历 寻找到开始位置</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lengthOfLastWord = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">let</span> end = s.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (end &gt; <span class="hljs-number">0</span> &amp;&amp; s[end] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>    end--;<br>  &#125;<br>  <span class="hljs-keyword">let</span> start = end;<br>  <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s[start] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>    start--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> end - start;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lengthOfLastWord2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">pop</span>().<span class="hljs-property">length</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35. 搜索插入位置-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="搜索插入位置-EASY"><a href="#搜索插入位置-EASY" class="headerlink" title="搜索插入位置-EASY"></a>搜索插入位置-EASY</h1><p><a href="https://leetcode.cn/problems/search-insert-position/">力扣题目</a></p><h1 id="方法一-二分查法"><a href="#方法一-二分查法" class="headerlink" title="方法一 二分查法"></a>方法一 二分查法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> searchInsert = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> res = nums.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-comment">// (right-left)&gt;&gt;1 向上取整</span><br>    <span class="hljs-keyword">let</span> mid = ((right - left) &gt;&gt; <span class="hljs-number">1</span>) + left;<br>    <span class="hljs-keyword">if</span> (target &lt;= nums[mid]) &#123;<br>      res = mid;<br>      right = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27. 移除元素-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/27.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/27.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="移除元素-EASY"><a href="#移除元素-EASY" class="headerlink" title="移除元素-EASY"></a>移除元素-EASY</h1><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目</a></p><h1 id="方法一-双指针法"><a href="#方法一-双指针法" class="headerlink" title="方法一 双指针法"></a>方法一 双指针法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, val</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (fast &lt; len) &#123;<br>    <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>      nums[slow] = nums[fast];<br>      slow++;<br>    &#125;<br>    fast++;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> slow;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-双指针法优化"><a href="#方法二-双指针法优化" class="headerlink" title="方法二 双指针法优化"></a>方法二 双指针法优化</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, val</span>) &#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>      nums[left] = nums[right - <span class="hljs-number">1</span>];<br>      right--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26. 删除有序数组中的重复项-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="删除有序数组中的重复项-EASY"><a href="#删除有序数组中的重复项-EASY" class="headerlink" title="删除有序数组中的重复项-EASY"></a>删除有序数组中的重复项-EASY</h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">力扣题目</a></p><h1 id="方法一-双指针法-快慢指针"><a href="#方法一-双指针法-快慢指针" class="headerlink" title="方法一 双指针法 快慢指针"></a>方法一 双指针法 快慢指针</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> nums;<br>  &#125;<br>  <span class="hljs-keyword">let</span> fast = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> slow = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (fast &lt; len) &#123;<br>    <span class="hljs-keyword">if</span> (nums[fast] &gt; nums[fast - <span class="hljs-number">1</span>]) &#123;<br>      nums[slow] = nums[fast];<br>      slow++;<br>    &#125;<br>    fast++;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> slow;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21. 合并两个有序链表-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="合并两个有序链表-EASY"><a href="#合并两个有序链表-EASY" class="headerlink" title="合并两个有序链表-EASY"></a>合并两个有序链表-EASY</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">力扣题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单链表的定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span> (<span class="hljs-params">list1, list2</span>) &#123;<br>  <span class="hljs-keyword">var</span> resList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>  <span class="hljs-keyword">var</span> tempList = resList;<br>  <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &lt; list2.<span class="hljs-property">val</span>) &#123;<br>      tempList.<span class="hljs-property">next</span> = list1;<br>      list1 = list1.<span class="hljs-property">next</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      tempList.<span class="hljs-property">next</span> = list2;<br>      list2 = list2.<span class="hljs-property">next</span>;<br>    &#125;<br>    tempList = tempList.<span class="hljs-property">next</span>;<br>  &#125;<br>  tempList.<span class="hljs-property">next</span> = list1 == <span class="hljs-literal">null</span> ? list2 : list1;<br>  <span class="hljs-keyword">return</span> resList.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20. 有效的括号-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的括号-EASY"><a href="#有效的括号-EASY" class="headerlink" title="有效的括号-EASY"></a>有效的括号-EASY</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目</a></p><h1 id="方法一-栈"><a href="#方法一-栈" class="headerlink" title="方法一 栈"></a>方法一 栈</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先入后出，后入先出的思路来解题</li><li>左括号入表示入栈，右括号表示出栈</li><li>最终栈为空说明结果有效</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = &#123; <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span> &#125;;<br>  <span class="hljs-keyword">let</span> temp = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (map[s[i]]) &#123;<br>      <span class="hljs-keyword">if</span> (temp[temp.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] != map[s[i]]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      temp.<span class="hljs-title function_">pop</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      temp.<span class="hljs-title function_">push</span>(s[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> temp.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-匹配法"><a href="#方法二-匹配法" class="headerlink" title="方法二 匹配法"></a>方法二 匹配法</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>匹配相连且完整的括号并移除直到没有结果未知</li><li>到最终结果为空时说明结果有效</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">while</span> (<br>    s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;()&#x27;</span>) !== -<span class="hljs-number">1</span> ||<br>    s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>) !== -<span class="hljs-number">1</span> ||<br>    s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;[]&#x27;</span>) !== -<span class="hljs-number">1</span><br>  ) &#123;<br>    s = s.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\(\)/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    s = s.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\&#123;\&#125;/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    s = s.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\[\]/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. 最长公共前缀-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共前缀-EASY"><a href="#最长公共前缀-EASY" class="headerlink" title="最长公共前缀-EASY"></a>最长公共前缀-EASY</h1><p><a href="https://leetcode.cn/problems/longest-common-prefix/">力扣题目</a></p><h1 id="方法一-横向扫描"><a href="#方法一-横向扫描" class="headerlink" title="方法一 横向扫描"></a>方法一 横向扫描</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>先取一个字符串，可以是数值中任何一位，也可以是最短那位，我们以第一个 strs[0]为例实现代码</li><li>去与下一位比较，得到公共部分。</li><li>然后再把公布部分一次去比较，更新得到最终结果</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = strs[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; strs.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> cStr = strs[i];<br>    <span class="hljs-keyword">const</span> minIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(res.<span class="hljs-property">length</span>, cStr.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; minIndex &amp;&amp; res.<span class="hljs-title function_">at</span>(index) == cStr.<span class="hljs-title function_">at</span>(index)) &#123;<br>      index++;<br>    &#125;<br>    res = res.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, index);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法一-纵向扫描"><a href="#方法一-纵向扫描" class="headerlink" title="方法一 纵向扫描"></a>方法一 纵向扫描</h1><p>横向扫描是那整个串去比较处理，那么纵向扫描就是那每一位去比较出来</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先与横向扫描一样需要确定一个起始字符串。我们以第一个 strs[0]为例实现代码</li><li>我们拿该字符串每个位置去与其他字符串对应位置比较，如果满足就进行下一次比较，直到出现不满足的情况后退出遍历然后结果。</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (strs[<span class="hljs-number">0</span>][j] != strs[i][j]) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>      &#125;<br>    &#125;<br>    res += strs[<span class="hljs-number">0</span>][j];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. 罗马数字转整数-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="罗马数字转整数-EASY"><a href="#罗马数字转整数-EASY" class="headerlink" title="罗马数字转整数-EASY"></a>罗马数字转整数-EASY</h1><p><a href="https://leetcode.cn/problems/roman-to-integer/">力扣题目</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>罗马数字 MDCLXVI &#x3D; 1000+500+100+50+10+5+1</li><li>规则 左大+ 右大- 例如 VI &#x3D; V + I 但是 IV &#x3D; V - I</li><li>因为左边可能存在最大值，减的逻辑判断相对比较复杂。所以我们可以从右开始解析。</li><li>从右到左出现下的值就- 大的值就+</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = &#123;<br>  <span class="hljs-attr">I</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">V</span>: <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">X</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">L</span>: <span class="hljs-number">50</span>,<br>  <span class="hljs-attr">C</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">D</span>: <span class="hljs-number">500</span>,<br>  <span class="hljs-attr">M</span>: <span class="hljs-number">1000</span><br>&#125;;<br><span class="hljs-keyword">var</span> romanToInt = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&#x27;I&#x27;</span>; <span class="hljs-comment">//防止出现 IIV 这种情况不太规范的情况，所以记录了右侧最近的大值</span><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = s.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span> (map[s[i]] &lt; map[temp]) &#123;<br>      res -= map[s[i]];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res += map[s[i]];<br>      temp = s[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 回文数-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/9.%20%E5%9B%9E%E6%96%87%E6%95%B0-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/9.%20%E5%9B%9E%E6%96%87%E6%95%B0-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="回文数-EASY"><a href="#回文数-EASY" class="headerlink" title="回文数-EASY"></a>回文数-EASY</h1><p><a href="https://leetcode.cn/problems/palindrome-number/">力扣题目</a></p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>判断是否只回文，只需要把结果倒序后和原结果相等就满足回文</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>负数一定不满足</li><li>当是 10、20 这类整十的数也一定不满足</li><li>首先数字转为字符串</li><li>把字符串转换成数组利用 reverse 倒序后重新转为字符串</li><li>判断是否相同就可以了</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> xArr = x.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">return</span> xArr.<span class="hljs-title function_">toString</span>() == xArr.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">toString</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>方法一是把数组转换类型后判断得到结果的。如果我们想只利用 number 类型 之间的比较来实现呢？以 123 举例</p><ol><li>3 &#x3D;&gt; 32 &gt; 321 我们需要这么一个过程组合的过程</li><li>当前值*10+原数字对应位数字</li><li>但是我们真的需要得到最终的 321 再进行比较吗？</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> reverseNumber = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> oldX = x;<br>  <span class="hljs-keyword">while</span> (reverseNumber &lt; x) &#123;<br>    reverseNumber = reverseNumber * <span class="hljs-number">10</span> + (oldX % <span class="hljs-number">10</span>);<br>    oldX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(oldX / <span class="hljs-number">10</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> x == reverseNumber;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>但上面处理视乎有点多余了，那我们对上述代码进行点简单的优化。</p><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> reverseNumber = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (reverseNumber &lt; x) &#123;<br>    reverseNumber = reverseNumber * <span class="hljs-number">10</span> + (x % <span class="hljs-number">10</span>);<br>    x = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(x / <span class="hljs-number">10</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> x == reverseNumber || x == <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(reverseNumber / <span class="hljs-number">10</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 最长回文子串-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="最长回文子串-MEDIUM"><a href="#最长回文子串-MEDIUM" class="headerlink" title="最长回文子串-MEDIUM"></a>最长回文子串-MEDIUM</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">力扣题目</a></p><h1 id="方法一-中心扩展算法"><a href="#方法一-中心扩展算法" class="headerlink" title="方法一 中心扩展算法"></a>方法一 中心扩展算法</h1><p>首先如何判断是回文字符串。然后不断的向两端扩展</p><ol><li>奇数情况 长度&#x3D;1 一定是 并且 s[i-n] &#x3D;&#x3D; s[i+n]</li><li>偶数情况 s[i-1] &#x3D; s[i+1] 并且 s[i-n] &#x3D;&#x3D; s[i+1+n]</li></ol><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先建立一个扩展方法，传入 left,right 计算后 返回新的 left,right</li><li>我们已知回文字符串会有 2 种场景, 遍历字符串 同时执行奇数、偶数情况，我们就可以得到两组关系</li><li>判断长度保存最长结果</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> expandAroundCenter = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, left, right</span>) &#123;<br>  <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-property">length</span> &amp;&amp; s[left] == s[right]) &#123;<br>    left--;<br>    right++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [left + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>];<br>&#125;;<br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">const</span> [l1, r1] = <span class="hljs-title function_">expandAroundCenter</span>(s, i, i);<br>    <span class="hljs-keyword">const</span> [l2, r2] = <span class="hljs-title function_">expandAroundCenter</span>(s, i, i + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (r1 - l1 &gt; end - start) &#123;<br>      start = l1;<br>      end = r1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r2 - l2 &gt; end - start) &#123;<br>      start = l2;<br>      end = r2;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">slice</span>(start, end + <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-动态规划"><a href="#方法二-动态规划" class="headerlink" title="方法二 动态规划"></a>方法二 动态规划</h1><p>首先我们先要明白一下的规则</p><ol><li>当 一个回文 i<del>j 那么 i+1</del>j-1 也一定满足回文（j-i&gt;&#x3D;3)</li><li>长度&#x3D;&#x3D;1 的话一定是个回文字符串</li></ol><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先我们需要保持是否满足回文的结果，我们可以利用 二维数组 dp[i][j]</li><li>长度&#x3D;&#x3D;1 一定是个回文字符串, dp[i][i] &#x3D; true;</li><li>接下来我们可以从回文长度 L&#x3D;2 开始判断 直到 L&#x3D;s.length</li><li>确立左右指针，i; j &#x3D; i + L -1;</li><li>s[i] !&#x3D; s[j] 不符合</li><li>s[i] &#x3D;&#x3D; s[j] 时需要判断 s[i+1] &#x3D;&#x3D; s[j-1] 是否符合，当然到 j-i&lt;3 时一定符合</li><li>判断保存最长结果</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  <span class="hljs-keyword">let</span> begin = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> dp = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    dp[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>      dp[i][j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//   所有长度为一的都是回文字符串;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    dp[i][i] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">//   回文的长度</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> L = <span class="hljs-number">2</span>; L &lt;= len; L++) &#123;<br>    <span class="hljs-comment">//   定义左指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 定义右指针</span><br>      <span class="hljs-keyword">let</span> j = i + L - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (j &gt;= len) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>        dp[i][j] = <span class="hljs-literal">false</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) &#123;<br>          dp[i][j] = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>        maxLen = j - i + <span class="hljs-number">1</span>;<br>        begin = i;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">slice</span>(begin, begin + maxLen);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 无重复字符的最长子串-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/16/subject/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/16/subject/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="无重复字符的最长子串-MEDIUM"><a href="#无重复字符的最长子串-MEDIUM" class="headerlink" title="无重复字符的最长子串-MEDIUM"></a>无重复字符的最长子串-MEDIUM</h1><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">力扣题目</a></p><h1 id="方法一-右查法"><a href="#方法一-右查法" class="headerlink" title="方法一 右查法"></a>方法一 右查法</h1><p>首先想到个笨办法，既然是得到无重复字符的最长子串，那么我们可以想办法获取每个位置开始的最长子串，进行比较获的最大值子串。</p><p>接下来我们进行代码上的实现和简单优化</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>遍历字符串得到每个开始位置 i</li><li>再次从 i 开始遍历字符串，得到最长子串 并保存在 temp 中</li><li>判断是否是最大长度，更新结果</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">const</span> len = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; len; j++) &#123;<br>      <span class="hljs-keyword">let</span> _s = s[j];<br>      <span class="hljs-keyword">if</span> (temp.<span class="hljs-title function_">indexOf</span>(_s) == -<span class="hljs-number">1</span>) &#123;<br>        temp += _s;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, temp.<span class="hljs-property">length</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法二-左查法"><a href="#方法二-左查法" class="headerlink" title="方法二 左查法"></a>方法二 左查法</h1><p>方法一我们每个最长子串都需要从 0 到 max 不到累加得到。<br>现在我们换个思路：<br>如果我们本直接得到上一个重复字符串的位置的话，那我们岂不是就可以快熟的得到最长子串了。<br>当然如何实现的还需要一些以为情况处理</p><ol><li>如果最大子串就是本事，或最大子串在结尾。这种情况下我们该如何得到字符串的开始位置呢？</li><li>当查询到重复字符位置后得到的字符串，该字符串如何保证内部不存在其他重复字符串呢？</li></ol><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先创建 map 保存历史[值,下标]的关系表</li><li>创建 left 保存左指针的位置。该指针十分重要，有效的解决上述提到的两个问题</li><li>遍历字符串 当 map 的到了下标并且位置在 left 右边时，说明该下标有效，更新 lefe。i - left 的到长度。</li><li>为什么下标要早 left 右边呢，因为到下标在 left 左边的话，说明中间存在了重复的字符。</li><li>如果 left 一直未被更新过说明 字符串本事就是最终结果</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">const</span> len = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> left = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">let</span> _s = s[i];<br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(_s) &amp;&amp; map.<span class="hljs-title function_">get</span>(_s) &gt;= left) &#123;<br>      left = map.<span class="hljs-title function_">get</span>(_s);<br>    &#125;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, i - left);<br>    map.<span class="hljs-title function_">set</span>(_s, i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 两数相加-MEDIUM</title>
    <link href="/xiaolanchong.githug.io/2023/04/15/subject/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-MEDIUM/"/>
    <url>/xiaolanchong.githug.io/2023/04/15/subject/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-MEDIUM/</url>
    
    <content type="html"><![CDATA[<h1 id="两数相加-MEDIUM"><a href="#两数相加-MEDIUM" class="headerlink" title="两数相加-MEDIUM"></a>两数相加-MEDIUM</h1><p><a href="https://leetcode.cn/problems/add-two-numbers/">力扣题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单链表的定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>链表 L1 L2 是逆序存储的, 所以我们只要同为相加就可以了</li><li>当长度不一时 缺少的位置直接 0 代替</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-keyword">function</span> (<span class="hljs-params">l1, l2</span>) &#123;<br>  <span class="hljs-keyword">let</span> resList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>  <span class="hljs-keyword">let</span> tempList = resList;<br>  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (l1 || l2 || carry) &#123;<br>    <span class="hljs-keyword">let</span> sum = (l1?.<span class="hljs-property">val</span> || <span class="hljs-number">0</span>) + (l2?.<span class="hljs-property">val</span> || <span class="hljs-number">0</span>) + carry;<br>    tempList.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>    tempList = tempList.<span class="hljs-property">next</span>;<br>    carry = (sum / <span class="hljs-number">10</span>) | <span class="hljs-number">0</span>;<br>    l1 = l1?.<span class="hljs-property">next</span>;<br>    l2 = l2?.<span class="hljs-property">next</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> resList.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 两数之和-EASY</title>
    <link href="/xiaolanchong.githug.io/2023/04/15/subject/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-EASY/"/>
    <url>/xiaolanchong.githug.io/2023/04/15/subject/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-EASY/</url>
    
    <content type="html"><![CDATA[<h1 id="两数之和-EASY"><a href="#两数之和-EASY" class="headerlink" title="两数之和-EASY"></a>两数之和-EASY</h1><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先可以创建一个 map 遍历数组记录[差值,下标], 这样我们就建立了一个目标值和当前值下标的关联表</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// nums数组  target目标</span><br><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>  map.<span class="hljs-title function_">set</span>([target - nums[i]], i);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>接下来我们只需要继续遍历数组，去查找当前值是否已经存在对应的关联</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>([nums[i]])) &#123;<br>    map.<span class="hljs-title function_">get</span>([nums[i]]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(nums[i])) &#123;<br>      <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(nums[i]), i];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map.<span class="hljs-title function_">set</span>(target - nums[i], i);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端的冷知识</title>
    <link href="/xiaolanchong.githug.io/2023/04/09/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
    <url>/xiaolanchong.githug.io/2023/04/09/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="有趣的隐式转换-x3D-x3D"><a href="#有趣的隐式转换-x3D-x3D" class="headerlink" title="有趣的隐式转换 [] &#x3D;&#x3D; ![]"></a>有趣的隐式转换 [] &#x3D;&#x3D; ![]</h1><blockquote><p>这是一个 js 隐式转换的问题</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[] == ![]; <span class="hljs-comment">// 右边是表达式，先进行计算，[]的boolean值为true，所以![]则为false</span><br>[] == <span class="hljs-literal">false</span>; <span class="hljs-comment">// 右边是基本类型，左边则是数组（对象类型），因此对左侧执行ToPrimitive</span><br><span class="hljs-comment">// ToPrimitive执行过程</span><br>[].<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// 结果为[]，valueOf返回的仍然是原数组对象，非基本类型，执行ToString</span><br>[].<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 结果为空字符串&#x27;&#x27;，为字符串基本类型，返回</span><br><span class="hljs-string">&#x27;&#x27;</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// 两边都为基本类型，类型仍然不同，两边同时执行ToNumber</span><br><span class="hljs-comment">// 两边同时ToNumber转化为数字类型</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-number">0</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h1><blockquote><p>数字向下取整首先我们会想到 <font color="#ffff00">Math.floor</font> 但今天介绍一个神奇的写法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">1.1</span> | <span class="hljs-number">0</span>) == <span class="hljs-number">1</span>; <span class="hljs-comment">//true</span><br>(<span class="hljs-number">1.9</span> | <span class="hljs-number">0</span>) == <span class="hljs-number">1</span>; <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h1 id="filter-属性和-position-冲突"><a href="#filter-属性和-position-冲突" class="headerlink" title="filter 属性和 position 冲突"></a>filter 属性和 position 冲突</h1><blockquote><p>当 filter 属性的值不是 none，则会为绝对和固定定位的子元素创建包含块，除非它所应用的元素是当前浏览器上下文的文档根元素</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS面试题</title>
    <link href="/xiaolanchong.githug.io/2023/04/09/interview/JS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/xiaolanchong.githug.io/2023/04/09/interview/JS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="New-操作符做了什么"><a href="#New-操作符做了什么" class="headerlink" title="New 操作符做了什么"></a>New 操作符做了什么</h1><ol><li>创建一个空对象</li><li>改变隐式原型的指向</li><li>改变构造函数 this 的指向</li><li>判断构造函数有无返回的对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>= name<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">f,…arg</span>)&#123;<br><span class="hljs-keyword">const</span> o = &#123;&#125;; <span class="hljs-comment">//1</span><br>o.<span class="hljs-property">__proto__</span>  = f.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<span class="hljs-comment">//2</span><br><span class="hljs-keyword">const</span> r = f.<span class="hljs-title function_">appy</span>(o, arg);<span class="hljs-comment">//3</span><br><span class="hljs-keyword">const</span> isTrue = r &amp;&amp; <span class="hljs-keyword">typeof</span> r === ‘<span class="hljs-keyword">function</span>’ || <span class="hljs-keyword">typeof</span> r === ‘object’;<span class="hljs-comment">//4</span><br><span class="hljs-keyword">return</span> isTrue ? r : o;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Js-检查数据类型"><a href="#Js-检查数据类型" class="headerlink" title="Js 检查数据类型"></a>Js 检查数据类型</h1><h2 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h2><blockquote><p>缺点：只能检查基本类型 null 类型的时候是 object</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// object</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// boolean</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// number</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">1n</span>; <span class="hljs-comment">// bigInt</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>; <span class="hljs-comment">// string</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// symbol</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(); <span class="hljs-comment">// function</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// number</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><h3 id="Q：为什么-typeof-检查-null-类型的时候是-object"><a href="#Q：为什么-typeof-检查-null-类型的时候是-object" class="headerlink" title="Q：为什么 typeof 检查 null 类型的时候是 object"></a>Q：为什么 typeof 检查 null 类型的时候是 object</h3><blockquote><p>A：JavaScript 存储是以 32 位字节进行存储的，而标志存储的时候遵循如下特定</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">000</span>：对象，数据是对象的应用。<br><span class="hljs-number">001</span>：整型，数据是 <span class="hljs-number">31</span> 位带符号整数。<br><span class="hljs-number">010</span>：双精度类型，数据是双精度数字。<br><span class="hljs-number">100</span>：字符串，数据是字符串。<br><span class="hljs-number">110</span>：布尔类型，数据是布尔值。<br><span class="hljs-literal">null</span> 作为机器代码 <span class="hljs-number">0</span> 号地址，也就是全部都是空，所以检测：<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> =&gt; <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><h2 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. instanceof</h2><blockquote><p>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p></blockquote><blockquote><p>缺点：不能检测基本类型</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">object</span> instanceof <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">object</span>：某个实例对象</span><br><span class="hljs-function"><span class="hljs-title">constructor</span>：某个构造函数</span><br></code></pre></td></tr></table></figure><h3 id="Q-instanceof-检测原理"><a href="#Q-instanceof-检测原理" class="headerlink" title="Q: instanceof 检测原理"></a>Q: instanceof 检测原理</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">拿到左边对象的原型链<span class="hljs-comment">;</span><br>拿到右边构造函数的显示原型 prototype<span class="hljs-comment">;</span><br>如果原型链中存在显示原型 返回 true<br></code></pre></td></tr></table></figure><h2 id="3-Object-prototype-toString-call"><a href="#3-Object-prototype-toString-call" class="headerlink" title="3. Object.prototype.toString.call()"></a>3. Object.prototype.toString.call()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// [object Number]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">1n</span>); <span class="hljs-comment">// [object BigInt]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;str&#x27;</span>); <span class="hljs-comment">// [object String]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [object Boolean]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [object Undefined]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// [object Null]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]); <span class="hljs-comment">// [object Array]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;&#125;); <span class="hljs-comment">// [object Object]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>()); <span class="hljs-comment">// [object Function]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">Symbol</span>()); <span class="hljs-comment">// [object Symbol]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()); <span class="hljs-comment">// [object Map]</span><br></code></pre></td></tr></table></figure><h1 id="for-in-与-for-of-的区别"><a href="#for-in-与-for-of-的区别" class="headerlink" title="for in 与 for of 的区别"></a>for in 与 for of 的区别</h1><ul><li>for in</li></ul><blockquote><p>对<font color="#ffff00">普通对象遍历其可枚举属性</font>获取键名</p></blockquote><p>普通对象&gt;可枚举属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// enumerable == true</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span> &#125;);<br></code></pre></td></tr></table></figure><ul><li>for of</li></ul><blockquote><p>对<font color="#ffff00">可迭代对象</font>循环迭代获取其键值</p></blockquote><p>可迭代对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Array Map Set String</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环</title>
    <link href="/xiaolanchong.githug.io/2023/04/09/interview/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/xiaolanchong.githug.io/2023/04/09/interview/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>相信在面试的时候小伙伴们都被问过 event loop。event loop 在前端是个比较重要的知识点，它涉及到一个代码执行循序的问题。</p><blockquote><p>想必在接触前端的时候老师们都说过 setTimeout 会在其他代码执行后最后再执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 输出循序是 2、1</span><br></code></pre></td></tr></table></figure><p>上述代码：那这又是为什么呢？</p><p>这就引出了今天我们要学习的问题 event loop</p><h1 id="为什么会有-event-loop"><a href="#为什么会有-event-loop" class="headerlink" title="为什么会有 event loop"></a>为什么会有 event loop</h1><blockquote><p>因为 js 是单线程的，如果某段程序需要等待一会再执行，后面的程序都会被阻塞，这样也就带来了一些问题。为了解决这个问题，js 出现了同步和异步两种任务，两种任务的差异就在于执行的优先级不同。event loop 就是对任务的执行顺序做了详细的规范。</p></blockquote><h1 id="同步和异步任务"><a href="#同步和异步任务" class="headerlink" title="同步和异步任务"></a>同步和异步任务</h1><blockquote><p>异步任务：异步任务分为宏任务和微任务</p></blockquote><ul><li>常见的微任务有:<ol><li>Promise.then catch finally</li><li>Object.observe</li><li>MutationObserver</li><li>process.nextTick（node 环境）</li></ol></li><li>常见的宏任务有:<ol><li>script</li><li>setTimeout</li><li>setInterval</li><li>postMessage</li><li>setImmediate（node 环境)</li><li>ajax</li><li>DOM 事件</li></ol></li></ul><h1 id="任务的执行顺序"><a href="#任务的执行顺序" class="headerlink" title="任务的执行顺序"></a>任务的执行顺序</h1><blockquote><p>先到后：同步任务 -&gt; 微任务 -&gt; 宏任务。</p></blockquote><h1 id="任务在哪里执行"><a href="#任务在哪里执行" class="headerlink" title="任务在哪里执行"></a>任务在哪里执行</h1><p>前面说到 js 是单线程的，所以</p><blockquote><p>无论是同步任务还是异步任务，都是在主线程执行。</p></blockquote><h1 id="什么是-event-loop"><a href="#什么是-event-loop" class="headerlink" title="什么是 event loop"></a>什么是 event loop</h1><p>事件循环（event loop）就是任务在主线程不断进栈出栈的一个循环过程。任务会在将要执行时进入主线程，在执行完毕后会退出主线程。</p><blockquote><p>下面是执行步骤</p></blockquote><blockquote><p>同步任务</p></blockquote><ol><li>把同步任务加入同步任务队列</li><li>把同步任务队列的任务加入主线程</li><li>主线程任务执行完毕，主线程队列清空</li></ol><blockquote><p>微任务</p></blockquote><ol start="4"><li>把微任务加入微任务队列</li><li>把微任务队列的任务加入主线程</li><li>主线程任务执行完毕，主线程队列清空</li></ol><blockquote><p>宏任务</p></blockquote><ol start="7"><li>把宏任务加入宏任务队列，无 time 的先加入，有 time 的按短到长先后加入</li><li>把宏任务队列的任务加入主线程</li><li>主线程任务执行完毕，主线程队列清空</li></ol><h1 id="案例巩固下"><a href="#案例巩固下" class="headerlink" title="案例巩固下"></a>案例巩固下</h1><blockquote><p>执行循序自行研究</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>&#125;, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">resolve</span>();<br>&#125;);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>();<br>  &#125;, <span class="hljs-number">0</span>);<br>&#125;);<br>p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 输出循序是 1,2,3,4,5,6,7,8</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高阶函数</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><blockquote><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数</p></blockquote><ul><li>接受一个或多个函数作为输入<blockquote><p>接受一个或多个函数作为参数传入 如：Array.prototype.map()和 Array,prototype.filter()</p></blockquote></li><li>输出一个函数。<blockquote><p>输出一个函数 如：debuonce 和 throttle</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debuonce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>();<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!flag) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>();<br>      flag = <span class="hljs-literal">true</span>;<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h1><blockquote><p>函数组合就是将两个或两个以上的函数组合生成一个新函数的过程：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">composeFn</span>(<span class="hljs-params">f, g</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(<span class="hljs-title function_">g</span>(x));<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 在以上代码中，f 和 g 都是函数，而 x 是组合生成新函数的参数。</span><br></code></pre></td></tr></table></figure><blockquote><p>但在项目开发中，为了实现函数的复用，我们通常会尽量保证函数职责的单一性，我们需要对单一函数进行自由的组合来实现需要的夯实<font color= "#FFFF00">（需要多少个函数组合是未知的）</font></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...fns</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> fns.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">arg, fn</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(arg);<br>    &#125;, x);<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 在以上的代码中，我们通过 Array.prototype.reduce 方法来实现组合函数的调度，对应的执行顺序是从左到右。不过如果你想从右往左开始执行的话，这时你就可以使用 Array.prototype.reduceRight 方法来实现。</span><br></code></pre></td></tr></table></figure><h1 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h1><blockquote><p>柯里化（Currying）是一种处理函数中含有多个参数的方法，并在只允许单一参数的框架中使用这些函数。这种转变是现在被称为 “柯里化” 的过程，在这个过程中我们能把一个带有多个参数的函数转换成一系列的嵌套函数。它返回一个新函数，这个新函数期望传入下一个参数。当接收足够的参数后，会自动执行原函数。<font color="#FFFF00">这里需要特别注意的是，在数学和理论计算机科学中的柯里化函数，一次只能传递一个参数。而对于 JavaScript 语言来说，在实际应用中的柯里化函数，可以传递一个或多个参数。</font></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= fn.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) &#123;<br>        <span class="hljs-keyword">return</span> curried.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(args2));<br>      &#125;;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><blockquote><p>在计算机科学中，偏函数应用（Partial Application）是指固定一个函数的某些参数，然后产生另一个更小元的函数。而所谓的元是指函数参数的个数，比如含有一个参数的函数被称为一元函数。</p></blockquote><blockquote><p>偏函数应用（Partial Application）很容易与函数柯里化混淆，它们之间的区别是：</p></blockquote><ul><li>偏函数应用是固定一个函数的一个或多个参数，并返回一个可以接收剩余参数的函数；</li><li>柯里化是将函数转化为多个嵌套的一元函数，也就是每个函数只接收一个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> newArgs = args.<span class="hljs-title function_">concat</span>([].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>));<br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, newArgs);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h1><blockquote><p>由于不同浏览器之间存在一些兼容性问题，这导致了我们在使用一些 Web API 时，需要进行判断，比如：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addHandler</span>(<span class="hljs-params">element, type, handler</span>) &#123;<br>  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">addEventListner</span>) &#123;<br>    element.<span class="hljs-title function_">addEventListner</span>(type, handler, <span class="hljs-literal">false</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">attachEvent</span>) &#123;<br>    element.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>, handler);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    element[<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>] = handler;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 在以上代码中，我们实现了不同浏览器 添加事件监听 的处理。代码实现起来也很简单，但存在一个问题，即每次调用的时候都需要进行判断，很明显这是不合理的。对于上述这个问题，我们可以通过惰性载入函数来解决。</span><br></code></pre></td></tr></table></figure><blockquote><p>惰性载入函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> addHandler = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">addEventListner</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">element, type, handler</span>) &#123;<br>      element.<span class="hljs-title function_">addEventListner</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125;;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">attachEvent</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">element, type, handler</span>) &#123;<br>      element.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>, handler);<br>    &#125;;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">element, type, handler</span>) &#123;<br>      element[<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>] = handler;<br>    &#125;;<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h1 id="缓存函数"><a href="#缓存函数" class="headerlink" title="缓存函数"></a>缓存函数</h1><blockquote><p>缓存函数是将函数的计算结果缓存起来，当下次以同样的参数调用该函数时，直接返回已缓存的结果，而无需再次执行函数。这是一种常见的以空间换时间的性能优化手段。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memorize</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> cache = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 存储缓存数据的对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> _args = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);<br>    <span class="hljs-keyword">return</span> cache[_args] || (cache[_args] = fn.<span class="hljs-title function_">apply</span>(fn, args));<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高阶函数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数组合</tag>
      
      <tag>柯里化函数</tag>
      
      <tag>偏函数</tag>
      
      <tag>惰性函数</tag>
      
      <tag>缓存函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器都做了什么</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h1><h2 id="1、解析-URL"><a href="#1、解析-URL" class="headerlink" title="1、解析 URL"></a>1、解析 URL</h2><ul><li>对 URL 进行解析 分析传输协议金和资源路径</li><li>协议或主机名是否合法<ul><li>是 检查 是否存在非法字符 并对其进行转义</li><li>否 内容传输给搜索引擎</li></ul></li></ul><h2 id="2、缓存判断"><a href="#2、缓存判断" class="headerlink" title="2、缓存判断"></a>2、缓存判断</h2><ul><li>浏览器是否存在资源缓存 是有有效<ul><li>是 直接使用</li><li>否 向服务器发起新的请求</li></ul></li></ul><h2 id="3、DNS-解析"><a href="#3、DNS-解析" class="headerlink" title="3、DNS 解析"></a>3、DNS 解析</h2><ul><li>获取 URL 中域名的 IP 地址</li><li>用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求</li><li>检查 本地 DNS 服务器 是否存在该域名的 IP 地址的缓存<ul><li>是 直接使用</li><li>否 请求跟域名服务器 &#x3D;&gt; 获得 负责的顶级域名服务器地址 &#x3D;&gt; 请求负责的顶级域名服务器 &#x3D;&gt; 获得域名的 IP 地址</li></ul></li></ul><h2 id="4、获取-MAC-地址"><a href="#4、获取-MAC-地址" class="headerlink" title="4、获取 MAC 地址"></a>4、获取 MAC 地址</h2><h2 id="5、TCP-三次握手"><a href="#5、TCP-三次握手" class="headerlink" title="5、TCP 三次握手"></a>5、TCP 三次握手</h2><ul><li>确认客户端与服务端的接受与发送能量</li><li>客户端发送 SYN 连接请求报文段和一个随机序号</li><li>服务端确认连接请求 并先客户端发送一个随机序号</li><li>客户端进入连接建立的状态，并向服务器发送一个 ACK 确认报文段</li><li>服务端接收确认后进入连接建立转态</li><li>双方的连接建立完成</li></ul><h2 id="6、HTTPS-握手"><a href="#6、HTTPS-握手" class="headerlink" title="6、HTTPS 握手"></a>6、HTTPS 握手</h2><ul><li>如果用的 HTTPS 协议 在通信前还存在 TLS 的第四次捂手过程</li><li>客户端发送 协议本部好 随机数 加密方法</li><li>服务端确认加密方法后发送 随机数 数字证书</li><li>客户端确认证书后发送 随机数并加密 全部内容的 hash</li><li>服务端解密随机数后发生 全部内容的 hash</li><li>此时双方都有 3 个随机数</li><li>加密生成秘钥</li></ul><h2 id="7、发送-HTTP-请求"><a href="#7、发送-HTTP-请求" class="headerlink" title="7、发送 HTTP 请求"></a>7、发送 HTTP 请求</h2><ul><li>服务端处理请求，返回 HTTP 报文</li></ul><h2 id="8、页面渲染"><a href="#8、页面渲染" class="headerlink" title="8、页面渲染"></a>8、页面渲染</h2><ul><li>解析 HTML 文件构建 DOM 树</li><li>解析 CSS 文件构建 CSSOM 树</li><li>如果遇到 script 标签判断是否同步加载还是异步加载</li><li>DOM 树与 CSSOM 树合成渲染树进行布局</li><li>布局完成后使用浏览器的 UI 接口对页面进行绘制</li></ul><h2 id="9、TCP-第四次握手"><a href="#9、TCP-第四次握手" class="headerlink" title="9、TCP 第四次握手"></a>9、TCP 第四次握手</h2><ul><li>最后一步是 TCP 端口连接的第四次握手过程</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computed和watch的区别</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/interview/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/interview/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>其实它只是 this.$watch 这个 API 的一种封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">name</span>(<span class="hljs-params">newName</span>) &#123;...&#125;<br>&#125;<br>&#125;<br><br>---------------------------------------------------------<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-function"><span class="hljs-params">newName</span> =&gt;</span> &#123;...&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听属性初始化"><a href="#监听属性初始化" class="headerlink" title="监听属性初始化"></a>监听属性初始化</h2><p>为什么这么说，我们首先来看下初始化时 watch 属性都做了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;  <span class="hljs-comment">// 初始化所有状态时</span><br>  vm.<span class="hljs-property">_watchers</span> = []  <span class="hljs-comment">// 当前实例watcher集合</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>  <span class="hljs-comment">// 合并后的属性</span><br><br>  ... <span class="hljs-comment">// 其他状态初始化</span><br><br>  <span class="hljs-keyword">if</span>(opts.<span class="hljs-property">watch</span>) &#123;  <span class="hljs-comment">// 如果有定义watch属性</span><br>    <span class="hljs-title function_">initWatch</span>(vm, opts.<span class="hljs-property">watch</span>)  <span class="hljs-comment">// 执行初始化方法</span><br>  &#125;<br>&#125;<br><br>---------------------------------------------------------<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initWatch</span> (vm, watch) &#123;  <span class="hljs-comment">// 初始化方法</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> watch) &#123;  <span class="hljs-comment">// 遍历watch内多个监听属性</span><br>    <span class="hljs-keyword">const</span> handler = watch[key]  <span class="hljs-comment">// 每一个监听属性的值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;  <span class="hljs-comment">// 如果该项的值为数组</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; handler.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-title function_">createWatcher</span>(vm, key, handler[i])  <span class="hljs-comment">// 将每一项使用watcher包装</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">createWatcher</span>(vm, key, handler) <span class="hljs-comment">// 不是数组直接使用watcher</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>---------------------------------------------------------<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWatcher</span> (vm, expOrFn, handler, options) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPlainObject</span>(handler)) &#123; <span class="hljs-comment">// 如果是对象，参数移位</span><br>    options = handler<br>    handler = handler.<span class="hljs-property">handler</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handler === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;  <span class="hljs-comment">// 如果是字符串，表示为方法名</span><br>    handler = vm[handler]  <span class="hljs-comment">// 获取methods内的方法</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> vm.$watch(expOrFn, handler, options)  <span class="hljs-comment">// 封装</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先初始化时，会判断并遍历 vm.$options.watch 属性，最终调用vm.$watch</p></blockquote><h2 id="监听属性实现原理"><a href="#监听属性实现原理" class="headerlink" title="监听属性实现原理"></a>监听属性实现原理</h2><p>所以我们来看下$watch 的内部实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$watch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">expOrFn, cb, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPlainObject</span>(cb)) &#123;  <span class="hljs-comment">// 如果cb是对象，当手动创建监听属性时</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createWatcher</span>(vm, expOrFn, cb, options)<br>  &#125;<br><br>  options.<span class="hljs-property">user</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// user-watcher的标志位，传入Watcher类中</span><br>  <span class="hljs-keyword">const</span> watcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expOrFn, cb, options)  <span class="hljs-comment">// 实例化user-watcher</span><br><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;  <span class="hljs-comment">// 立即执行</span><br>    cb.<span class="hljs-title function_">call</span>(vm, watcher.<span class="hljs-property">value</span>)  <span class="hljs-comment">// 以当前值立即执行一次回调函数</span><br>  &#125;  <span class="hljs-comment">// watcher.value为实例化后返回的值</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unwatchFn</span> () &#123;  <span class="hljs-comment">// 返回一个函数，执行取消监听</span><br>    watcher.<span class="hljs-title function_">teardown</span>()<br>  &#125;<br>&#125;<br><br>---------------------------------------------------------------<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cc&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">unwatch</span> = <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-function"><span class="hljs-params">newName</span> =&gt;</span> &#123;...&#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unwatch</span>()  <span class="hljs-comment">// 取消监听</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>虽然 watch 内部是使用 this.$watch，当我们还是可以通过 this.$watch 来创建监听的，所以第二个参数 cb 会出现对象的情况。</p></blockquote><ul><li>设置标记 options.user&#x3D;true,表明这是一个 user-watcher。</li><li>再给 watch 设置了 immediate 属性后，会将实例化后得到的值传入回调，并立即执行一次回调函数，这也是 immediate 的实现原理。</li><li>最后的返回值是一个方法，执行后可以取消对该监听属性的监听。接下来我们看看 user-watcher 是如何定义的：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm<br>    vm.<span class="hljs-property">_watchers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 添加到当前实例的watchers内</span><br><br>    <span class="hljs-keyword">if</span>(options) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span> = !!options.<span class="hljs-property">deep</span>  <span class="hljs-comment">// 是否深度监听</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = !!options.<span class="hljs-property">user</span>  <span class="hljs-comment">// 是否是user-wathcer</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span> = !!options.<span class="hljs-property">sync</span>  <span class="hljs-comment">// 是否同步更新</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// // 派发更新的标志位</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb  <span class="hljs-comment">// 回调函数</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;  <span class="hljs-comment">// 如果expOrFn是函数</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-title function_">parsePath</span>(expOrFn)  <span class="hljs-comment">// 如果是字符串对象路径形式，返回闭包函数</span><br>    &#125;<br><br>    ...<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当是 user-watcher 时，Watcher 内部是以上方式实例化的，通常情况下我们是使用字符串的形式创建监听属性，所以首先来看下 parsePath 方法是干什么的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bailRE = <span class="hljs-regexp">/[^\w.$]/</span>; <span class="hljs-comment">// 得是对象路径形式，如info.name</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parsePath</span>(<span class="hljs-params">path</span>) &#123;<br>  <span class="hljs-keyword">if</span> (bailRE.<span class="hljs-title function_">test</span>(path)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不匹配对象路径形式，再见</span><br><br>  <span class="hljs-keyword">const</span> segments = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>); <span class="hljs-comment">// 按照点分割为数组</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-comment">// 闭包返回一个函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; segments.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>      obj = obj[segments[i]]; <span class="hljs-comment">// 依次读取到实例下对象末端的值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>parsePath 方法最终返回一个闭包方法，此时 Watcher 类中的 this.getter 就是一个函数了，再执行 this.get()方法时会将 this.vm 传入到闭包内，补全 Watcher 其他的逻辑：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br><br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-title function_">parsePath</span>(expOrFn)  <span class="hljs-comment">// 返回的方法</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">// 执行get</span><br>  &#125;<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 将当前user-watcher实例赋值给Dep.target，读取时收集它</span><br><br>    <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>)  <span class="hljs-comment">// 将vm实例传给闭包，进行读取操作</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span>) &#123;  <span class="hljs-comment">// 如果有定义deep属性</span><br>      <span class="hljs-title function_">traverse</span>(value)  <span class="hljs-comment">// 进行深度监听</span><br>    &#125;<br><br>    <span class="hljs-title function_">popTarget</span>()<br>    <span class="hljs-keyword">return</span> value  <span class="hljs-comment">// 返回闭包读取到的值，参数immediate使用的就是这里的值</span><br>  &#125;<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为之前初始化已经将状态已经全部都代理到了 this 下，所以读取 this 下的属性即可，比如：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// data的初始化先与watch</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cc&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;info.name&#x27;</span>, <span class="hljs-function"><span class="hljs-params">newName</span> =&gt;</span> &#123;...&#125;)  <span class="hljs-comment">// 何况手动创建</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先读取 this 下的 info 属性，然后读取 info 下的 name 属性。大家注意，这里我们使用了读取这个动词，所以会执行之前包装 data 响应式数据的 get 方法进行依赖收集，将依赖收集到读取到的属性的 dep 里，不过收集的是 user-watcher，get 方法最后返回闭包读取到的值。</p></blockquote><blockquote><p>之后就是当 info.name 属性被重新赋值时，走派发更新的流程，我们这里把和 render-watcher 不同之处做单独的说明，派发更新会执行 Watcher 内的 update 方法内：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br>    ...<br>  &#125;<br><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 执行派发更新</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span>) &#123;  <span class="hljs-comment">// 如果有设置sync为true</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>()  <span class="hljs-comment">// 不走nextTick队列，直接执行</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// 否则加入队列，异步执行run()</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAndInvoke</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>)  <span class="hljs-comment">// 传入回调函数</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">getAndInvoke</span>(<span class="hljs-params">cb</span>) &#123;<br>    <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">// 重新求值</span><br><br>    <span class="hljs-keyword">if</span>(value !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> || <span class="hljs-title function_">isObject</span>(value) || <span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span>) &#123;<br>      <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>  <span class="hljs-comment">// 缓存之前的值</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value  <span class="hljs-comment">// 新值</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;  <span class="hljs-comment">// 如果是user-watcher</span><br>        cb.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, value, oldValue)  <span class="hljs-comment">// 在回调内传入新值和旧值</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其实这里的 sync 属性已经没在官网做说明了，不过我们看到源码中还是保留了相关代码。接下来我们看到为什么 watch 的回调内可以得到新值和旧值的原理，因为 cb.call(this.vm, value, oldValue)这句代码的原因，内部将新值和旧值传给了回调函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// watch监听属性示例：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// App组件</span><br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cc&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">name</span>(<span class="hljs-params">newName, oldName</span>) &#123;...&#125;  <span class="hljs-comment">// 派发新值和旧值给回调</span><br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ww&#x27;</span>  <span class="hljs-comment">// 触发name的set</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听属性的-deep-深度监听原理"><a href="#监听属性的-deep-深度监听原理" class="headerlink" title="监听属性的 deep 深度监听原理"></a>监听属性的 deep 深度监听原理</h2><p>之前的 get 方法内有说明，如果有 deep 属性，则执行 traverse 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> seenObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 不重复添加</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-title function_">_traverse</span>(val, seenObjects);<br>  seenObjects.<span class="hljs-title function_">clear</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_traverse</span>(<span class="hljs-params">val, seen</span>) &#123;<br>  <span class="hljs-keyword">let</span> i, keys;<br>  <span class="hljs-keyword">const</span> isA = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(val); <span class="hljs-comment">// val是否是数组</span><br><br>  <span class="hljs-keyword">if</span> (<br>    (!isA &amp;&amp; !<span class="hljs-title function_">isObject</span>(val)) || <span class="hljs-comment">// 如果不是array和object</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(val) || <span class="hljs-comment">// 或者是已经冻结对象</span><br>    val <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">VNode</span><br>  ) &#123;<br>    <span class="hljs-comment">// 或者是VNode实例</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 再见</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (val.<span class="hljs-property">__ob__</span>) &#123;<br>    <span class="hljs-comment">// 只有object和array才有__ob__属性</span><br>    <span class="hljs-keyword">const</span> depId = val.<span class="hljs-property">__ob__</span>.<span class="hljs-property">dep</span>.<span class="hljs-property">id</span>; <span class="hljs-comment">// 手动依赖收集器的id</span><br>    <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(depId)) &#123;<br>      <span class="hljs-comment">// 已经有收集过</span><br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 再见</span><br>    &#125;<br>    seen.<span class="hljs-title function_">add</span>(depId); <span class="hljs-comment">// 没有被收集，添加</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (isA) &#123;<br>    <span class="hljs-comment">// 是array</span><br>    i = val.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-title function_">_traverse</span>(val[i], seen); <span class="hljs-comment">// 递归触发每一项的get进行依赖收集</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 是object</span><br>    keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(val);<br>    i = keys.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-title function_">_traverse</span>(val[keys[i]], seen); <span class="hljs-comment">// 递归触发子属性的get进行依赖收集</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>看着还挺复杂，简单来说 deep 的实现原理就是递归的触发数组或对象的 get 进行依赖收集，因为只有数组和对象才有<strong>ob</strong>属性，也就是我们第七章说明的手动依赖管理器，将它们的依赖收集到 Observer 类里的 dep 内，完成 deep 深度监听。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这里说明了为什么 watch 和 this.$watch 的实现是一致的，以及简单解释它的原理就是为需要观察的数据创建并收集 user-watcher，当数据改变时通知到 user-watcher 将新值和旧值传递给用户自己定义的回调函数。最后分析了定义 watch 时会被使用到的三个参数：sync、immediate、deep 它们的实现原理。简单说明它们的实现原理就是：sync 是不将 watcher 加入到 nextTick 队列而同步的更新、immediate 是立即以得到的值执行一次回调函数、deep 是递归的对它的子值进行依赖收集。</p></blockquote><h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>计算属性不是 API，但它是 Watcher 类,也是最复杂的一种实例化的使用。</p><p>分析计算属性为何可以做到当依赖发生变化时才会重新计算，否则数据被缓存。</p><p>计算属性的值也可以是对象，这个对象需要传入 get 和 set 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">newName</span>: &#123;  <span class="hljs-comment">// 不分析这种了~</span><br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;...&#125;,  <span class="hljs-comment">// 内部会采用get属性为计算属性的值</span><br>      <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>) &#123;...&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算属性初始化"><a href="#计算属性初始化" class="headerlink" title="计算属性初始化"></a>计算属性初始化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params">vm</span>) &#123;  <span class="hljs-comment">// 初始化所有状态时</span><br>  vm.<span class="hljs-property">_watchers</span> = []  <span class="hljs-comment">// 当前实例watcher集合</span><br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span>  <span class="hljs-comment">// 合并后的属性</span><br><br>  ... <span class="hljs-comment">// 其他状态初始化</span><br><br>  <span class="hljs-keyword">if</span>(opts.<span class="hljs-property">computed</span>) &#123;  <span class="hljs-comment">// 如果有定义计算属性</span><br>    <span class="hljs-title function_">initComputed</span>(vm, opts.<span class="hljs-property">computed</span>)  <span class="hljs-comment">// 进行初始化</span><br>  &#125;<br>  ...<br>&#125;<br><br>---------------------------------------------------------------------------<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span>(<span class="hljs-params">vm, computed</span>) &#123;<br>  <span class="hljs-keyword">const</span> watchers = vm.<span class="hljs-property">_computedWatchers</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 创建一个纯净对象</span><br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;<br>    <span class="hljs-keyword">const</span> getter = computed[key]  <span class="hljs-comment">// computed每项对应的回调函数</span><br><br>    watchers[key] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, getter, noop, &#123;<span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>&#125;)  <span class="hljs-comment">// 实例化computed-watcher</span><br><br>    ...<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算属性实现原理"><a href="#计算属性实现原理" class="headerlink" title="计算属性实现原理"></a>计算属性实现原理</h2><blockquote><p>这里还是按照惯例，将定义的 computed 属性的每一项使用 Watcher 类进行实例化，不过这里是按照 computed-watcher 的形式，来看下如何实例化的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb, options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_watchers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>);<br><br>    <span class="hljs-keyword">if</span> (options) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span> = !!options.<span class="hljs-property">lazy</span>; <span class="hljs-comment">// 表示是computed</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>; <span class="hljs-comment">// dirty为标记位，表示是否对computed计算</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn; <span class="hljs-comment">// computed的回调函数</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的 App 组件在执行 extend 创建子组件的构造函数时，已经将 key 挂载到 vm 的原型中了，不过之前也是执行的 defineComputed 方法，所以不妨碍我们看它做了什么：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span>(<span class="hljs-params">target, key</span>) &#123;<br>  ...<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">get</span>: <span class="hljs-title function_">createComputedGetter</span>(key),<br>    <span class="hljs-attr">set</span>: noop<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个方法的作用就是让 computed 成为一个响应式数据，并定义它的 get 属性，也就是说当页面执行渲染访问到 computed 时，才会触发 get 然后执行 createComputedGetter 方法，所以之前的点到为止再这里会续上，看下 get 方法是怎么定义的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComputedGetter</span> (key) &#123; <span class="hljs-comment">// 高阶函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 返回函数</span><br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]<br>    <span class="hljs-comment">// 原来this还可以这样用，得到key对应的computed-watcher</span><br><br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) &#123;  <span class="hljs-comment">// 在实例化watcher时为true，表示需要计算</span><br>        watcher.evaluate()  <span class="hljs-comment">// 进行计算属性的求值</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;  <span class="hljs-comment">// 当前的watcher，这里是页面渲染触发的这个方法，所以为render-watcher</span><br>        watcher.<span class="hljs-title function_">depend</span>()  <span class="hljs-comment">// 收集当前watcher</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span>  <span class="hljs-comment">// 返回求到的值或之前缓存的值</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>------------------------------------------------------------------------------------<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  ...<br><br>  evaluate () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">//  计算属性求值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 表示计算属性已经计算，不需要再计算</span><br>  &#125;<br><br>  depend () &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>  <span class="hljs-comment">// deps内是计算属性内能访问到的响应式数据的dep的数组集合</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>()  <span class="hljs-comment">// 让每个dep收集当前的render-watcher</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的变量 watcher 就是之前 computed 对应的 computed-watcher 实例，接下来会执行 Watcher 类专门为计算属性定义的两个方法，在执行 evaluate 方法进行求值的过程中又会触发 computed 内可以访问到的响应式数据的 get，它们会将当前的 computed-watcher 作为依赖收集到自己的 dep 里，计算完毕之后将 dirty 置为 false，表示已经计算过了。</p></blockquote><blockquote><p>然后执行 depend 让计算属性内的响应式数据订阅当前的 render-watcher，所以 computed 内的响应式数据会收集 computed-watcher 和 render-watcher 两个 watcher，当 computed 内的状态发生变更触发 set 后，首先通知 computed 需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到 computed 计算后的值，最后渲染到页面。</p></blockquote><blockquote><p>当 computed 内的响应式数据变更后触发的通知：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  ...<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 当computed内的响应式数据触发set后</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">diray</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 通知computed需要重新计算了</span><br>    &#125;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最后还是以一个示例结合流程图来帮大家理清楚这里的逻辑：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">manName</span>: <span class="hljs-string">&#x27;cc&#x27;</span>,<br>      <span class="hljs-attr">womanName</span>: <span class="hljs-string">&#x27;ww&#x27;</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">newName</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">manName</span> + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">womanName</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">changeName</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">manName</span> = <span class="hljs-string">&#x27;ss&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote><p>为什么计算属性有缓存功能？因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值；为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？因为内部的响应式数据会收集 computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值。</p></blockquote><p><a href="https://juejin.cn/post/6844903926819454983#heading-0">查看原文</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的一些面试题</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/interview/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/interview/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h1><blockquote><p>老常规第一问</p></blockquote><ul><li>Vue2：beforeCreate &#x3D;&gt; created &#x3D;&gt; beforeMount &#x3D;&gt; mounted &#x3D;&gt; beforeUpdate &#x3D;&gt; updated &#x3D;&gt; beforeDestroy &#x3D;&gt; destroyed</li><li>Vue3：setup &#x3D;&gt; onBeforeMount &#x3D;&gt; onMount &#x3D;&gt; onBeforeUpdate &#x3D;&gt; onUpdated &#x3D;&gt; onBeforeUnmount &#x3D;&gt; onUnmounted</li></ul><blockquote><p>keep-alive</p></blockquote><ul><li>Vue2：activated 、deactivated</li><li>Vue3：onActivated 、onDeactivated</li></ul><blockquote><p>捕获一个来自子孙组件的异常</p></blockquote><ul><li>vue2：errorCaptured</li><li>vue3：onErrorCaptured</li></ul><h1 id="父子生命周期的顺序"><a href="#父子生命周期的顺序" class="headerlink" title="父子生命周期的顺序"></a>父子生命周期的顺序</h1><p>子组件先挂载，然后父组件，更新也类似</p><h1 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h1><p>v-model 是 vue 的语法糖</p><p>input[text&#x2F;number&#x2F;password]、textarea 元素使用的 value 属性和 input 事件</p><p>input[checkbox&#x2F;radio]元素使用的 checked 属性和 change 事件</p><p>select 元素将 value 作为 prop 并将 change 作为事件</p><h1 id="为什么-data-是个函数"><a href="#为什么-data-是个函数" class="headerlink" title="为什么 data 是个函数"></a>为什么 data 是个函数</h1><p>因为组件会被复用需要保证唯一性</p><h1 id="Keep-alive-的了解"><a href="#Keep-alive-的了解" class="headerlink" title="Keep-alive 的了解"></a>Keep-alive 的了解</h1><p>keep-alive 是 vue 内部的组件 可以使被包含的组件保留状态，避免重新渲染</p><ol><li>一般结合路由和动态组件一起使用，用于缓存组件</li><li>提供的 include 和 exclude 属性<ul><li>include &#x3D;&gt; 只有匹配的会缓存</li><li>exclude &#x3D;&gt; 匹配的不会缓存 优先级比 include 高</li></ul></li><li>对象两个特殊钩子函数 activated 和 deactivated</li></ol><h1 id="computed-和-watch-的区别和运用场景"><a href="#computed-和-watch-的区别和运用场景" class="headerlink" title="computed 和 watch 的区别和运用场景"></a>computed 和 watch 的区别和运用场景</h1><ul><li>computed:计算属性,有缓存,当我们需要进行数值计算，并且依赖于其他数据时使用</li><li>watch:监听,当我们需要异步或开销较大的操作时使用,可以根据需要限制我们操作的频次</li></ul><a href="/xiaolanchong.githug.io/2023/04/08/interview/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/" title="computed和watch的区别">computed和watch的区别</a><h1 id="聊聊-nextTick"><a href="#聊聊-nextTick" class="headerlink" title="聊聊 nextTick"></a>聊聊 nextTick</h1><ol><li>把回调函数放入 callbacks 等待执行</li><li>将执行函数放入微任务或宏任务中<blockquote><p>为什么是微任务或宏任务？<br>对当前环境进行了降级处理 Promise &#x3D;&gt; MutationObserver &#x3D;&gt; setImmediate &#x3D;&gt; setTimeout (1、2 微任务 3、4 宏任务)</p></blockquote></li><li>事件循环到微任务或宏任务，执行函数依次执行 callbacks 中的回调</li></ol><h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><blockquote><p>为什么使用 render 函数？</p></blockquote><p>VUE 推荐在绝大多数情况下使用 template 来创建我们的 HTML。然而在一些场景中，我们真的需要 JavaScript 的完全编程的能力，这就是 render 函数，它比 template 更接近编译器。（这是官方的话）<br>简单来说，我们为什么要使用 render 函数呢？？ 便是因为我们最经常使用的一个引入。</p><blockquote><p>render 函数的解析</p></blockquote><p>render 函数即渲染函数，它是个函数，它的参数 createElement 也是个函数。</p><p>createElement 有三个参数</p><ol><li>一个 HTML 标签字符串 必选</li><li>一个包含模板相关属性的数据对象 可选</li><li>子虚拟节点 可选</li></ol><p><a href="https://blog.csdn.net/m0_59722204/article/details/126907040">查看原文</a></p><h1 id="v-show-与-v-if-的区别"><a href="#v-show-与-v-if-的区别" class="headerlink" title="v-show 与 v-if 的区别"></a>v-show 与 v-if 的区别</h1><ul><li>v-if 是条件渲染 确保在切换过程中条件块内的事件监听器和子组件适当地被销毁重建</li><li>v-show 元素总会被渲染，且只是简单地基于 display 属性进行切换</li></ul><h1 id="Class-与-Style-如何动态绑定"><a href="#Class-与-Style-如何动态绑定" class="headerlink" title="Class 与 Style 如何动态绑定"></a>Class 与 Style 如何动态绑定</h1><ul><li>对象语法</li><li>数组语法</li></ul><h1 id="vue-router-路由模式有几种"><a href="#vue-router-路由模式有几种" class="headerlink" title="vue-router 路由模式有几种"></a>vue-router 路由模式有几种</h1><ol><li>hash location.hash 向服务端发出请求是 hash 部分不会被发送</li><li>history HTML5 提供了 History API 来实现 URL 的变化<ul><li>history.pushState()</li><li>history.repalceState()</li></ul></li><li>abstract 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ol><h1 id="SPA-单页的理解-优缺点"><a href="#SPA-单页的理解-优缺点" class="headerlink" title="SPA 单页的理解 优缺点"></a>SPA 单页的理解 优缺点</h1><ul><li>SPA 仅在页面初始化时加载相应的 html、js、css 等</li><li>SPA 不会因为用户的操作而进行页面的重新加载和跳转；取而代之的是利用路由机制实现页面内容的变化</li></ul><blockquote><p>优点：</p></blockquote><ol><li>用户体验好、快、内容的改变不需重新加载整个页面，避免不必要的跳转和重新渲染</li><li>SPA 相对服务器压力小；</li><li>前后端分离，架构清晰，前端负责交互逻辑，后端提供相应的数据接口；</li></ol><blockquote><p>缺点：</p></blockquote><ol><li>首屏加载等待问题；</li><li>SEO 难度大</li></ol><blockquote><p>SPA</p></blockquote><ol><li>CSR 客户端渲染&#x3D;&gt;当前主流模式</li><li>SSR 服务端渲染&#x3D;&gt;能较好的解决 SEO 的问题</li><li>Prerender 预渲染&#x3D;&gt;打包阶段预先生成页面</li><li>同构 两者的结合&#x3D;&gt; 参考框架 Nuxt.js</li></ol><div class="note note-warning">            <p>注：SSR 需要路由需要使用 history 模式</p>          </div>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件间的通讯方式</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/interview/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/interview/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-组件间的通讯方式"><a href="#Vue-组件间的通讯方式" class="headerlink" title="Vue 组件间的通讯方式"></a>Vue 组件间的通讯方式</h1><div class="note note-warning">            <p>Vue 是单项数据流</p>          </div><h2 id="父组件向子组件传递-props"><a href="#父组件向子组件传递-props" class="headerlink" title="父组件向子组件传递 props"></a>父组件向子组件传递 props</h2><p>父组件通过 props 向子组件传递数据，子组件通过 $emit 和父组件通信</p><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msg&quot;</span> <span class="hljs-attr">:fn</span>=<span class="hljs-string">&quot;changeMsg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Function</span></span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fn(&#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="子组件向父组件传递-emit"><a href="#子组件向父组件传递-emit" class="headerlink" title="子组件向父组件传递 $emit"></a>子组件向父组件传递 $emit</h2><p>$emit 的特点</p><ul><li>$emit 绑定一个自定义事件，当事件被执行的时候会将参数传递给父组件，而父组件通过 v-on 监听并接受参数</li></ul><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-attr">fn</span>=<span class="hljs-string">&quot;changeMsg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;fn&#x27;</span>]);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;fn&#x27;, &#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="兄弟组件传递"><a href="#兄弟组件传递" class="headerlink" title="兄弟组件传递"></a>兄弟组件传递</h2><ol><li>兄弟组件间通信可以借助父组件交互</li></ol><h2 id="ref-x2F-refs"><a href="#ref-x2F-refs" class="headerlink" title="ref &#x2F; $refs"></a>ref &#x2F; $refs</h2><p>该方法也是实现父子组件通信的</p><p>ref: 该属性用在子组件上，他指向子组件的实例，可以通过实例来访问组件的数据和方法</p><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-comment">// vue3需要主动暴露</span></span><br><span class="language-javascript">  <span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">    msg,</span><br><span class="language-javascript">    changeMsg</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> refChild = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// onMounted后才能获取到</span></span><br><span class="language-javascript">    refChild.<span class="hljs-property">value</span>?.<span class="hljs-title function_">changeMsg</span>(str);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;refChild&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg(&#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="依赖注入-provide-x2F-inject"><a href="#依赖注入-provide-x2F-inject" class="headerlink" title="依赖注入 provide &#x2F; inject"></a>依赖注入 provide &#x2F; inject</h1><p>该方法就是 vue 中的依赖主人，该方法用于父子&#x2F;祖孙组件间的通信</p><p>provide&#x2F;inject 是 vue 提供的两个钩子</p><ul><li>provide 用来发送数据或方法</li><li>inject 用来接受数据或方法</li></ul><blockquote><p>父组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeMsg</span> = (<span class="hljs-params">str</span>) =&gt; &#123;</span><br><span class="language-javascript">    msg.<span class="hljs-property">value</span> = str;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;msg&#x27;</span>, msg);</span><br><span class="language-javascript">  <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;changeMsg&#x27;</span>, changeMsg);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref, inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;msg&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> changeMsg = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;changeMsg&#x27;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg(&#x27;change msg&#x27;)&quot;</span>&gt;</span>change msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="parent-x2F-children"><a href="#parent-x2F-children" class="headerlink" title="$parent &#x2F; $children"></a>$parent &#x2F; $children</h2><blockquote><p>$parent</p></blockquote><blockquote><p>$children（vue3 已移除）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h2 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h2><h2 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h2><h2 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs $listeners"></a>$attrs $listeners</h2>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diff算法</title>
    <link href="/xiaolanchong.githug.io/2023/04/07/interview/Diff%E7%AE%97%E6%B3%95/"/>
    <url>/xiaolanchong.githug.io/2023/04/07/interview/Diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、首先什么是虚拟-DOM"><a href="#1、首先什么是虚拟-DOM" class="headerlink" title="1、首先什么是虚拟 DOM?"></a>1、首先什么是虚拟 DOM?</h2><p>虚拟 DOM 就是一个普通的 JS 对象，用来描述真实的 DOM 结构的对象</p><h2 id="2、什么事-Diff-算法？"><a href="#2、什么事-Diff-算法？" class="headerlink" title="2、什么事 Diff 算法？"></a>2、什么事 Diff 算法？</h2><p>diff 算法是用来比较虚拟节点、并返回一个 patch 对象，用来存储新旧节点不同的地方<br>简单来说：diff 的过程就是调用 patch 函数，比较新旧节点，边比较边给 DOM 打补丁</p><blockquote><p>那么 diff 算法有什么特征呢？</p></blockquote><ol><li>比较只会发生在同层级进行，不会跨层级比较</li><li>diff 比较的过程中，循环从两边向中间比较</li></ol><blockquote><p>diff 算法的步骤</p></blockquote><ul><li>用 js 对象结构表示 ODM 的结构，然后用这个树结果创建一个真实的 DOM，插入到页面中</li><li>当状态发生变化时，重新构造一个新的对象树</li><li>新旧对象树进行比较（diff）,记录差异变化</li><li>把记录的差异应用到真实 DOM 树上（patch），完成视图的更新</li></ul><blockquote><p>原理分析</p></blockquote><p>当数据发生变化时，set 方法会调用 Dep.notify 通知所以得订阅者 Watcher,订阅者会调用 patch 给真实的 DOM 打补丁，更新响应的视图</p><h2 id="Vue2-中的-Diff"><a href="#Vue2-中的-Diff" class="headerlink" title="Vue2 中的 Diff"></a>Vue2 中的 Diff</h2><blockquote><p>双端 diff 算法</p></blockquote><ol><li>当数据发生变化时，订阅者 Watcher 会调用 patch 给真实 DOM 打补丁</li><li>通过 SameVnode(oldVode, newVode)进行判断，相同时则调用 patchVnode 方法</li><li>patchVnode<ul><li>判断文本节点，直接设置文本</li><li>子节点比较<br>一方不存在是，直接删除或创建<br>两者都有时，执行 updateChildren 函数比较子节点</li></ul></li><li>updateChildren<ul><li>设置新旧 vnode 的头尾指针</li><li>新旧头尾进行比较，循环先中间靠拢（四个角向中间靠拢比较）<br>根据情况调用 patchVnode 进行 patch 重复流程、调用 createElem 创建一个新的节点<br>从哈希表寻找 key 一致的 vNode 节点再分情况操作</li></ul></li></ol><h2 id="vue3-中的-Diff"><a href="#vue3-中的-Diff" class="headerlink" title="vue3 中的 Diff"></a>vue3 中的 Diff</h2><blockquote><p>快速 diff 算法</p></blockquote><p>Vue3 在真正的 diff 之前会执行一段“预处理”的前置操作，目的是先把科一直接排除的项直接去掉</p><ol><li>对比新旧节点头部相同指针的节点，相同则进行 diff，不同就跳转下一步</li><li>新旧节点尾部指针指向的节点，相同则进行 diff，不同就跳转下一步</li><li>此时剩余新旧节点可能存在乱序、一移除、新创建的情况，进行特殊处理来更新<ul><li>增删节点</li><li>diff<br>首先根据新节点剩余内容，跟 key 创建一个 map 映射<br>最长递增子序列 为减少 dom 的操作</li></ul></li></ol><blockquote><p>vue3 牺牲了一部分 js 性能，换来了 dom 渲染的性能</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Diff</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向数据绑定</title>
    <link href="/xiaolanchong.githug.io/2023/04/07/interview/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/xiaolanchong.githug.io/2023/04/07/interview/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h2><p>简单来说就是数据层和视图层之间实现相互绑定<br>也就是说视图发生变化数据会发生变化，同理数据发生变化视图也会发生相应的改变</p><h2 id="双向数据绑定的原理（MVVM）"><a href="#双向数据绑定的原理（MVVM）" class="headerlink" title="双向数据绑定的原理（MVVM）"></a>双向数据绑定的原理（MVVM）</h2><ul><li>M 数据层</li><li>V 视图层</li><li>VM 业务处理层（核心层）<ul><li>监听器 Obsever 对所有数据的属性进行监听</li><li>解析器 Compiler 对每个元素节点进行解析</li></ul></li></ul><h2 id="如何实现双向绑定"><a href="#如何实现双向绑定" class="headerlink" title="如何实现双向绑定"></a>如何实现双向绑定</h2><ul><li>初始化 对 data 执行响应处理 Obsever</li><li>同时对模版执行编译从 data 中获取动态数据，并初始化视图 Compiler</li><li>同时定义一个更新函数和 Watcher 将来对象数据发生变化时 Watcher 会调用更新函数</li><li>由于 data 的某个属性 key 在视图中可能出现多次，所以每个 key 都需要有一个 Dep 来管理多个 Watcher</li><li>将来 data 中数据一旦发生变化，会首先找到对应的 Dep 通知所有的 Watcher 执行更新函数</li></ul><p><img src="/xiaolanchong.githug.io/images/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" alt="双向数据绑定原理"></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
