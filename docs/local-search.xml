<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue的一些面试题</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h1><p>v-model 是 vue 的语法糖</p><p>input[text&#x2F;number&#x2F;password]、textarea 元素使用的 value 属性和 input 事件</p><p>input[checkbox&#x2F;radio]元素使用的 checked 属性和 change 事件</p><p>select 元素将 value 作为 prop 并将 change 作为事件</p><h1 id="为什么-data-是个函数"><a href="#为什么-data-是个函数" class="headerlink" title="为什么 data 是个函数"></a>为什么 data 是个函数</h1><p>因为组件会被复用需要保证唯一性</p><h1 id="Keep-alive-的了解"><a href="#Keep-alive-的了解" class="headerlink" title="Keep-alive 的了解"></a>Keep-alive 的了解</h1><p>keep-alive 是 vue 内部的组件 可以使被包含的组件保留状态，避免重新渲染</p><ol><li>一般结合路由和动态组件一起使用，用于缓存组件</li><li>提供的 include 和 exclude 属性<ul><li>include &#x3D;&gt; 只有匹配的会缓存</li><li>exclude &#x3D;&gt; 匹配的不会缓存 优先级比 include 高</li></ul></li><li>对象两个特殊钩子函数 activated 和 deactivated</li></ol><h1 id="computed-和-watch-的区别和运用场景"><a href="#computed-和-watch-的区别和运用场景" class="headerlink" title="computed 和 watch 的区别和运用场景"></a>computed 和 watch 的区别和运用场景</h1><ul><li>computed:计算属性,有缓存,当我们需要进行数值计算，并且依赖于其他数据时使用</li><li>watch:监听,当我们需要异步或开销较大的操作时使用,可以根据需要限制我们操作的频次</li></ul><h1 id="聊聊-nextTick"><a href="#聊聊-nextTick" class="headerlink" title="聊聊 nextTick"></a>聊聊 nextTick</h1><ol><li>把回调函数放入 callbacks 等待执行</li><li>将执行函数放入微任务或宏任务中<blockquote><p>为什么是微任务或宏任务？<br>对当前环境进行了降级处理 Promise &#x3D;&gt; MutationObserver &#x3D;&gt; setImmediate &#x3D;&gt; setTimeout (1、2 微任务 3、4 宏任务)</p></blockquote></li><li>事件循环到微任务或宏任务，执行函数依次执行 callbacks 中的回调</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件间的通讯方式</title>
    <link href="/xiaolanchong.githug.io/2023/04/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/"/>
    <url>/xiaolanchong.githug.io/2023/04/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-组件间的通讯方式"><a href="#Vue-组件间的通讯方式" class="headerlink" title="Vue 组件间的通讯方式"></a>Vue 组件间的通讯方式</h1><div class="note note-warning">            <p>Vue 是单项数据流</p>          </div><h2 id="父组件向子组件传递-props"><a href="#父组件向子组件传递-props" class="headerlink" title="父组件向子组件传递 props"></a>父组件向子组件传递 props</h2><p>父组件通过 props 向子组件传递数据，子组件通过 $emit 和父组件通信</p><blockquote><p>父组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>import Child from &#x27;./components/Child.vue&#x27;;<br><br>const msg = ref(&#x27;msg&#x27;);<br>const changeMsg = (str) =&gt; &#123;<br>  msg.value = str;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;Child :msg=&quot;msg&quot; :fn=&quot;changeMsg&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineProps(&#123;<br>  msg: String,<br>  fn: Function<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;<br>  &lt;button @click=&quot;fn(&#x27;change msg&#x27;)&quot;&gt;change msg&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="子组件向父组件传递-emit"><a href="#子组件向父组件传递-emit" class="headerlink" title="子组件向父组件传递 $emit"></a>子组件向父组件传递 $emit</h2><p>$emit 的特点</p><ul><li>$emit 绑定一个自定义事件，当事件被执行的时候会将参数传递给父组件，而父组件通过 v-on 监听并接受参数</li></ul><blockquote><p>父组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>import Child from &#x27;./components/Child.vue&#x27;;<br><br>const msg = ref(&#x27;msg&#x27;);<br>const changeMsg = (str) =&gt; &#123;<br>  msg.value = str;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;Child :msg=&quot;msg&quot; @fn=&quot;changeMsg&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineProps(&#123;<br>  msg: String<br>&#125;);<br>defineEmits([&#x27;fn&#x27;]);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;<br>  &lt;button @click=&quot;$emit(&#x27;fn&#x27;, &#x27;change msg&#x27;)&quot;&gt;change msg&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="兄弟组件传递"><a href="#兄弟组件传递" class="headerlink" title="兄弟组件传递"></a>兄弟组件传递</h2><ol><li>兄弟组件间通信可以借助父组件交互</li></ol><h2 id="ref-x2F-refs"><a href="#ref-x2F-refs" class="headerlink" title="ref &#x2F; $refs"></a>ref &#x2F; $refs</h2><p>该方法也是实现父子组件通信的</p><p>ref: 该属性用在子组件上，他指向子组件的实例，可以通过实例来访问组件的数据和方法</p><blockquote><p>子组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>const msg = ref(&#x27;msg&#x27;);<br>const changeMsg = (str) =&gt; &#123;<br>  msg.value = str;<br>&#125;;<br>// vue3需要主动暴露<br>defineExpose(&#123;<br>  msg,<br>  changeMsg<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>父组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>import Child from &#x27;./components/Child.vue&#x27;;<br>const refChild = ref(null);<br>const changeMsg = (str) =&gt; &#123;<br>  // onMounted后才能获取到<br>  refChild.value?.changeMsg(str);<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;Child ref=&quot;refChild&quot; /&gt;<br>  &lt;button @click=&quot;changeMsg(&#x27;change msg&#x27;)&quot;&gt;change msg&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h1 id="依赖注入-provide-x2F-inject"><a href="#依赖注入-provide-x2F-inject" class="headerlink" title="依赖注入 provide &#x2F; inject"></a>依赖注入 provide &#x2F; inject</h1><p>该方法就是 vue 中的依赖主人，该方法用于父子&#x2F;祖孙组件间的通信</p><p>provide&#x2F;inject 是 vue 提供的两个钩子</p><ul><li>provide 用来发送数据或方法</li><li>inject 用来接受数据或方法</li></ul><blockquote><p>父组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, provide &#125; from &#x27;vue&#x27;;<br>import Child from &#x27;./components/Child.vue&#x27;;<br>const msg = ref(&#x27;msg&#x27;);<br>const changeMsg = (str) =&gt; &#123;<br>  msg.value = str;<br>&#125;;<br>provide(&#x27;msg&#x27;, msg);<br>provide(&#x27;changeMsg&#x27;, changeMsg);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;<br>  &lt;Child /&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, inject &#125; from &#x27;vue&#x27;;<br>const msg = inject(&#x27;msg&#x27;);<br>const changeMsg = inject(&#x27;changeMsg&#x27;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;<br>  &lt;button @click=&quot;changeMsg(&#x27;change msg&#x27;)&quot;&gt;change msg&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="parent-x2F-children"><a href="#parent-x2F-children" class="headerlink" title="$parent &#x2F; $children"></a>$parent &#x2F; $children</h2><blockquote><p>$parent</p></blockquote><blockquote><p>$children（vue3 已移除）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">this.$children[0].message = &#x27;JavaScript&#x27;<br></code></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h2 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h2><h2 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h2><h2 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs $listeners"></a>$attrs $listeners</h2>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diff算法</title>
    <link href="/xiaolanchong.githug.io/2023/04/07/Diff%E7%AE%97%E6%B3%95/"/>
    <url>/xiaolanchong.githug.io/2023/04/07/Diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、首先什么是虚拟-DOM"><a href="#1、首先什么是虚拟-DOM" class="headerlink" title="1、首先什么是虚拟 DOM?"></a>1、首先什么是虚拟 DOM?</h2><p>虚拟 DOM 就是一个普通的 JS 对象，用来描述真实的 DOM 结构的对象</p><h2 id="2、什么事-Diff-算法？"><a href="#2、什么事-Diff-算法？" class="headerlink" title="2、什么事 Diff 算法？"></a>2、什么事 Diff 算法？</h2><p>diff 算法是用来比较虚拟节点、并返回一个 patch 对象，用来存储新旧节点不同的地方<br>简单来说：diff 的过程就是调用 patch 函数，比较新旧节点，边比较边给 DOM 打补丁</p><blockquote><p>那么 diff 算法有什么特征呢？</p></blockquote><ol><li>比较只会发生在同层级进行，不会跨层级比较</li><li>diff 比较的过程中，循环从两边向中间比较</li></ol><blockquote><p>diff 算法的步骤</p></blockquote><ul><li>用 js 对象结构表示 ODM 的结构，然后用这个树结果创建一个真实的 DOM，插入到页面中</li><li>当状态发生变化时，重新构造一个新的对象树</li><li>新旧对象树进行比较（diff）,记录差异变化</li><li>把记录的差异应用到真实 DOM 树上（patch），完成视图的更新</li></ul><blockquote><p>原理分析</p></blockquote><p>当数据发生变化时，set 方法会调用 Dep.notify 通知所以得订阅者 Watcher,订阅者会调用 patch 给真实的 DOM 打补丁，更新响应的视图</p><h2 id="Vue2-中的-Diff"><a href="#Vue2-中的-Diff" class="headerlink" title="Vue2 中的 Diff"></a>Vue2 中的 Diff</h2><blockquote><p>双端 diff 算法</p></blockquote><ol><li>当数据发生变化时，订阅者 Watcher 会调用 patch 给真实 DOM 打补丁</li><li>通过 SameVnode(oldVode, newVode)进行判断，相同时则调用 patchVnode 方法</li><li>patchVnode<ul><li>判断文本节点，直接设置文本</li><li>子节点比较<br>一方不存在是，直接删除或创建<br>两者都有时，执行 updateChildren 函数比较子节点</li></ul></li><li>updateChildren<ul><li>设置新旧 vnode 的头尾指针</li><li>新旧头尾进行比较，循环先中间靠拢（四个角向中间靠拢比较）<br>根据情况调用 patchVnode 进行 patch 重复流程、调用 createElem 创建一个新的节点<br>从哈希表寻找 key 一致的 vNode 节点再分情况操作</li></ul></li></ol><h2 id="vue3-中的-Diff"><a href="#vue3-中的-Diff" class="headerlink" title="vue3 中的 Diff"></a>vue3 中的 Diff</h2><blockquote><p>快速 diff 算法</p></blockquote><p>Vue3 在真正的 diff 之前会执行一段“预处理”的前置操作，目的是先把科一直接排除的项直接去掉</p><ol><li>对比新旧节点头部相同指针的节点，相同则进行 diff，不同就跳转下一步</li><li>新旧节点尾部指针指向的节点，相同则进行 diff，不同就跳转下一步</li><li>此时剩余新旧节点可能存在乱序、一移除、新创建的情况，进行特殊处理来更新<ul><li>增删节点</li><li>diff<br>首先根据新节点剩余内容，跟 key 创建一个 map 映射<br>最长递增子序列 为减少 dom 的操作</li></ul></li></ol><blockquote><p>vue3 牺牲了一部分 js 性能，换来了 dom 渲染的性能</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Diff</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向数据绑定</title>
    <link href="/xiaolanchong.githug.io/2023/04/07/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/xiaolanchong.githug.io/2023/04/07/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h2><p>简单来说就是数据层和视图层之间实现相互绑定<br>也就是说视图发生变化数据会发生变化，同理数据发生变化视图也会发生相应的改变</p><h2 id="双向数据绑定的原理（MVVM）"><a href="#双向数据绑定的原理（MVVM）" class="headerlink" title="双向数据绑定的原理（MVVM）"></a>双向数据绑定的原理（MVVM）</h2><ul><li>M 数据层</li><li>V 视图层</li><li>VM 业务处理层（核心层）<ul><li>监听器 Obsever 对所有数据的属性进行监听</li><li>解析器 Compiler 对每个元素节点进行解析</li></ul></li></ul><h2 id="如何实现双向绑定"><a href="#如何实现双向绑定" class="headerlink" title="如何实现双向绑定"></a>如何实现双向绑定</h2><ul><li>初始化 对 data 执行响应处理 Obsever</li><li>同时对模版执行编译从 data 中获取动态数据，并初始化视图 Compiler</li><li>同时定义一个更新函数和 Watcher 将来对象数据发生变化时 Watcher 会调用更新函数</li><li>由于 data 的某个属性 key 在视图中可能出现多次，所以每个 key 都需要有一个 Dep 来管理多个 Watcher</li><li>将来 data 中数据一旦发生变化，会首先找到对应的 Dep 通知所有的 Watcher 执行更新函数</li></ul><p><img src="/xiaolanchong.githug.io/images/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" alt="双向数据绑定原理"></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
